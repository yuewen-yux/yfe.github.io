<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AMP 开发体验洗白之路]]></title>
    <url>%2F2020%2F01%2F15%2F20200115%2F</url>
    <content type="text"><![CDATA[难用 or 姿势不对？「用户体验 &gt; 开发体验」Google AMP 的设计准则毫不掩饰地标记了它的核心观念，从一开始就承认了它对开发者的不友好。 「Webnovel m 站」作为国内首批使用 AMP 技术的产品「关于 AMP，Webnovel 都做了什么？」之一，结论上创造了显著提升的性能数据，过程中正如谷歌核心观点所说，开发体验非常差。最近得来一次机会，我们 Webnovel 面向非洲用户的新产品「Ficool m 站」实践了全站 AMP，从中找到了使用 AMP 的新姿势 - 「Next.js + AMP + Preact」，开发体验提升了不止一个档次，在此分享给大家。 开启洗白之路 - 从新项目入手Ficool m站作为 Webnovel 面向非洲地区的站点，它不仅覆盖 web 渠道，其借助 Google TWA 技术打包而成的轻量 APP 还将预装到 Android Go 系统的手机上，此系统对 APP 内存、CPU 占用有着严格的要求，现已成功入库。目前「Ficool m 站」大多数页面还暂未被 Google 搜索引擎收录，后续可以跟大家分享一下实际的效果以及我们在服务端做的进阶优化。 Why AMP?比起「Ficool m 站是什么？」，对本文来说更重要的是「Again，Why AMP ？」 一则演讲的启发今年 AMP conf 中一位伊拉克小哥的演讲令人印象深刻。 「No poser, no internet, no support: How AMP bridges the app gap in Iraq and other war-impacked region」 身处于战乱、网络条件落后的国家，他们选择使用 AMP，并借助 AMP 提供的一系列组件及优化方案一步步地填补了 APP 在体验、兼容性方面的落差，从而建立起了 APP 和曾经他们主动放弃的一批落后用户之间的桥梁。 国内的我们每天享受着 4G 可能某一天享受的就是 5G，很难想象遥远的非洲兄弟们忍受着怎样的网络条件… 我们的产品也终于有机会去了一趟非洲「肯尼亚」，并带回了一些「前线」消息 “ 那里的网速虽然没有想象中差，但普遍使用 3G 网络且速度有限，同时移动网络套餐相比国内要贵很多。” 「带宽贵」 「网速慢」 「 Webnovel m 站」在 AMP 上尝鲜成功 这 3 点已经足够推进「Ficool m 站」全站 AMP 的想法了，不仅如此，我们还走了一条 AMP 的小众路线 - 「Next.js + AMP + Preact」。 洗白的最佳姿势Next.js + AMP + Preact有了 「Webnovel m 站」的经验教训，我们预留时间做了大量的前期调研，并设定了一些目标： 开发过程效率要提升 代码后期可维护性要高 关注开发者身心：尽量使用一些现有的主流技术，摆脱旧的开发模式 最终 get 了 Next.js + AMP + Preact 这样的组合方式，听起来好像比 AMP + HTML 洋气了一些？这其实是一个极少人尝试过的 AMP 开发形式，在开发时间的压迫下一步棋走错全盘皆输！其过程采坑无数，大家不妨看看我们都经历了哪些历程。 2个历程的采坑1、从 HTML「硬写 」 到 React回顾「Webnovel m 站」 AMP 的旧开发方式：直接在 HTML 中引入 AMP 组件，以开发 HTML 的方式编写 AMP 页面 - 不可忍！ 实际上，Next.js 在 8.1 版本以上就已经支持了 AMP 的开发，这意味着我们完全可以直接用 React 开发 AMP 页面。 抽组件旧方式「图 1」对于组件的提取较为困难，借助 EJS 模板固然可以抽离 template 的部分并使用 include 语法将其引入，但 amp-list 的部分很难提取成组件（template 的部分是不确定的），而在 React AMP 中，我们可以将其提取成组件，并通过增加失败「fallback」、加载中「placeholder」等功能「图3」，使 amp-list 用起来更灵活。 「图 1：列表页 - HTML 旧方式开发」 「图 2：列表页 - React 方式开发」 「图 3：列表页 amp-list 组件 - React」 同样的，旧开发模式下能难做到服务端渲染（直出）部分、异步渲染部分的模板统一，这是由于 HTML 直出模板「 EJS 模板」语法和 AMP 的 「mustache template 模板」语法是截然不同的，然而在 React AMP 中我们却可以： 例如「图 2」中的 &lt;BookItemTtoB&gt; 组件，直出部分自然是正常传递 props，而 amp-list 的模板部分只需要用 mustache 模板语法 传递值即可 ，&lt;BookItemTtoB&gt; 也就达到了两种情景下的复用。 编写样式继续回顾之前的旧开发方式：样式必须内联放于 HTML 中的 &lt;style amp-custom&gt; 标签内，就当时的本地开发流程来说，要实现直接编译 scss 文件并将生成的 css 内联到 &lt;style amp-custom&gt; 标签内，改造起来远没有添加一条 webpack 配置那么简单，最终我们粗暴地将 css 文件用 EJS 引入模板的方式 include 到了 &lt;style&gt; 标签内，这显然不太优雅。 新的开发流程下，我们只需在 next.config.js 中拓展 webpack 的配置即可：引入 sass-loader 以及 Next.js 内置的 styled-jsx 「图4」，Next.js 会直接将编译好的 css 内联到 &lt;style amp-custom&gt; 标签内「图 5」，就是这么简单。 「图 4：next.config.js 中编译 css 相关配置」 「图 5：组件中引入样式」 总结： 1、用 React 方式开发 AMP 页面，组件的提取更简单。 2、页面的逻辑相比冗长的 HTML 代码更易维护且风格统一「单一 React 风格 VS HTML + EJS + mustache 混用」。 3、样式的编写更加容易、开发形式也吻合当前趋势。 2、AMP 页面的羽翼 - amp-script第一阶段我们实现了用 React 愉快地进行 AMP 的开发，但局限是：React 的生命周期函数不能用、一切自定义的 JS 交互依然不能实现（AMP 不允许引入我们自己的 JavaScript ）。 好消息！在今年 4 月中旬 AMP 发布了 amp-script，借助它就可以写我们自己的脚本了！当然，它有一定局限性：大小上限（ uncompressed 150KB），数量限制（每个页面只允许引入 1 个 amp-script ）以及 API 限制 … 不管有多少限制，为了实现更多的复杂交互，我们需要使用这个能力。 amp-script 非常规用法 - 使用 PreactAMP 官方提供的 amp-script demo 基本都是原生 Javascript 的写法，而在我们的 React AMP 项目中很不希望维护 2 种风格的代码，因此我们探索了用 React 开发 amp-script 的可能性。 首先是解决大小限制问题： 「各框架源码 uncompressed 大小」 size ( uncompressed ) amp-script 剩余空间 React 110kb 150 - 110 = 40kb Preact 8.2kb 150 - 8.2 = 141.8kb 「图 6：React vs Preact in amp-script」 React 源码足足有 110kb，如果使用 React，那我们自己的脚本只能写 40kb，这显然不够，因此我们选择了既能保持 React 开发风格、又能控制 amp-script 大小的 「Preact，React 的轻量版」。 webpack 实现 amp-script 的编译&amp;打包amp-script 的引入方法不同于普通的 React 组件「图 7、图 8」，其中 amp-script 组件必须有 src 属性，其值为你引入的脚本文件 url（绝对地址），由于每个页面只能引 1 个脚本，我们需要保证这个脚本已经是打包后的最终脚本，此时毫无疑问要使用 webpack 进行依赖分析及打包了。 「图 7：普通组件的引入方式」 「图 8：amp-script 的引入脚本的方式」 我们重新为 amp-script 的打包写了个独立的 webpack 配置「webpack.amp.config」，使其编译打包过程更加单一简单，尽量不和 next.config.js 的配置项搞混。 此 webpack.amp.config 的目标：对目标脚本进行依赖分析，最终经过 babel 编译打包成我们所需的 es5 脚本（此脚本就是 amp-script 最终引用的脚本）。 这个功能算是 webpack 比较基本的功能了，按 webpack 官网 demo 使用即可，重点配置项可参考「图 9」，其中 getAllAmpScriptEntries() 会获取所有需要编译的 amp-script 脚本路径，最终生成的脚本存放于 Next.js 托管的静态资源文件夹下 ./static。 「图 9：amp-script webpack 配置项重点部分」 amp-script 开发方式尘埃落定至此，我们已经可以正常享用 Preact 版 amp-script 了。如果只是简单的 DOM 操作，可以将需要被操作的 DOM 放在 amp-script 标签内、通过 ID 选择器获取元素即可，但我们既然使用了 Preact， 更推荐的做法是：需要操作的 DOM 全权由 amp-script 引用的 Preact 脚本渲染出来。 例如「图 10」中蓝色吸底栏，它涉及到的交互有：点击后展示 confirm 弹窗、请求后端进行相关操作（加入/移除书架）、接口返回成功后进行前端回显，普通页面的交互不外乎如此，具体实现思路是：React AMP 页面准备一个空的具有 ID 标识的 div 容器，借助 Preact 的 render 方法渲染出吸底栏组件，直接在 Preact 中进行事件的绑定、setState 更新 UI 等逻辑。 「图 10：详情页吸底栏使用 amp-script 脚本渲染」 amp-script 脚本 CDN 化借助 CDN 可以减轻服务器的压力、最快地响应用户，因此所有的 JavaScript 资源都应该放于 CDN 上，amp-script 当然不能例外。 amp-script 的打包编译流程是独立于 Next.js 的，但当我们打包 Next 脚本时，两个独立流程的融合不可避免，我们希望执行 build 命令后，amp-script 的 src 地址将会被替换为 CDN 域名，同时 amp-script 脚本文件名也会加上 md5 码… 来继续倒腾 next.config.js 吧！ amp-script 的 src 路径替换 + 文件名 md5 化，这个需求和绝大多数图片的引入基本一样，因此用 webpack 的 file-loader 就可以实现「图 11」。 「图 11：file-loader 替换 amp-script 路径」 为避免报错，test 对应的正则建议只匹配 amp-script 的脚本，同时 publicPath 也需进行「本地/线上」的区分用以保证本地能够正常引用 amp-script 脚本（本地依旧访问 /static/ 路径下的脚本）。为配合 file-loader 的使用，AMP 页面中也需把 amp-script 脚本的引用方式替换为 require() 方法引用。 一套流程下来，完全解决了 amp-script 脚本路径替换 + 文件名加 md5 的需求。 amp-script 脚本跨域问题完美解决到了这一步，眼看着 amp-script 享受到了 CDN 的待遇、Next 服务减轻了一些压力，然而却爆出了跨域错误「图 12」。 此跨域问题是 amp-script 自身的一套安全策略抛出的异常，官方说明可参考「图 13」，大致意思是，如果我们引用的 amp-script 脚本和页面 URL 域名不同，需要在各页面 meta 标签内，添加 amp-script-src 对应的 hash code ，此 code 根据脚本内容、基于 Content Security Policy 「CSP」生成，是每个脚本独一无二的编码。 「图 12：amp-script 跨域报错」 「图 13：amp-script 安全策略」 幸好 AMP 官方也提供了 CSP hash code 的生成工具@ampproject/toolbox-script-csp，我们初步的思路定了下来： 开发 webpack 自定义 plugin，具体功能：获取编译后的 amp-script 脚本，同目录下生成对应的 hash code 文件。 每个 AMP 页面添加 meta 标签，其 content 为引入的 hash code 文件。 Next.js 配置 raw-loader ，实现 meta 标签内 content 内容替换为 hash code 文件内容。 Step 1: webpack 自定义 plugin 此 plugin 功能单一还算好写，可以参考如下「图 14」，重点是获取到编译后的 amp-script 脚本内容、生成 hash code 、存放于同一路径下的 hash.txt 文件内。最终在 webpack 配置文件中 plugins 中引入此插件并实例化即可。 「图 14：webpack 自定义 plugin」 Step 2 &amp; Step 3: next.config.js 配置 raw-loader，AMP 页面引入 hash code 文件 页面中的改动如下所示： 「图 15：AMP 页面中引入 hash code 文件，添加 meta 标签」 next.config.js 中也需要配置 raw-loader，实现 meta 标签内 content 值的替换。 「图 16：next.config.js 中配置 raw-loader」 跨域问题得以解决！ 总结：实现了 amp-script React 方式开发的全过程。有了自定义的脚本能力，AMP 页面的开发更加灵活。 最后一层加持至此，开发过程中难免还会面临一些 amp-script 都无法实现的交互形式，这样的交互着实挑战了 AMP 的设计原则，换句话说，如果能够做到交互形式上完全遵循 AMP 的规范，开发体验则会畅通无阻！ AMP 设计原则AMP 设计原则中，没有规定你具体要怎样设计、怎样实施，但核心原则必须是：只做对用户体验有利的事情！其中有2条原则对我们开发者来说会有一定的启发「图 17」 「图 17：AMP 设计原则 2 条」 4.涉及到开发的各个层面应职责分明，在正确的层解决问题。 5.只做可以让网页变快的事情。 逻辑后置「涉及到开发的各个层面应职责分明，在正确的层解决问题」- 如果逻辑放于后端来说对用户体验较为友好，请不要仅仅因为前端实现起来简单，而把所有的逻辑都放在前端。 这里有一些场景可以参考： 需要使用 amp-mustache 组件（弱逻辑的模板语言，不支持运算、正则以及一些复杂判断逻辑）时，很多逻辑应该尽量让后端同学实现，例如：搜索页关键词高亮逻辑「图 18」，后端可以直接返回带有高亮样式的 HTML 元素。 对于长列表页面，下拉加载功能可以使用 amp-list 组件，但这需要后端协助加字段返回下一页的请求 URL 并携带参数、同时需要判断是否是最后一页而做逻辑的变更。当然前端也可以用 amp-script 实现下拉加载，但是其效果远没有直接引用 amp-list 好，此时逻辑后置很有必要。 「图 18：搜索页关键词蓝色高亮」 AMP 实现不了的窘迫场景只做可以让网页变快的事情 - AMP 不推荐引入任何会导致动画帧率变慢、页面加载速度受限的组件、特性。 我对它的理解是，如果不能保证自己写的组件完全符合 AMP 标准，那就尽量用 AMP 提供的组件吧！这里不得不再泼一下冷水了，amp-script 真的有很多限制，它并不能实现所有交互逻辑，只是给开发者开了个不大不小的窗户而已。这种情况只有 2 条路可选了： 调整需求和设计稿。 妥协、不使用 AMP。项目组各部门 follow 一致的规范如果你提前看到了此文，那么情况可能并没有那么糟，因为你可以防范于未然，以下就是良方。 AMP 的设计原则有个很好的初衷： 「 These design principles are meant to guide the ongoing design and development of AMP. They should help us make internally consistent decisions. 」 （让我们做出一致的决定） 其中 “我们”，指的不仅是 AMP 页面前端开发者，而是参与这个项目的所有人，这个出发点非常重要，这也是 AMP 2019 CONF 「AMP core mindset」提到的主要观念。 产品需要了解 AMP 的限制，避免天马行空的需求设计；设计也需要了解 AMP 的组件规范，进而节约设计成本、产出可以用 AMP 技术实现出来的组件，最终避免开发成本的增加。例如， 图片轮播组件 AMP 自身已经实现的很好了「图 19」，设计如果没有特殊要求，不需要再设计新的风格。 「图 19：amp 轮播图组件 amp-carousel」 从开发层面来讲，前端在拿到设计稿后，就可以清楚的看出页面可以用到的 AMP 组件，对于后端同学来说，开发前期就知道该补什么字段、做哪些逻辑调整。 结束语经过踩坑无数的坎坷历程，「Next.js + AMP + Preact 」这个 AMP 的新尝试在「Ficool m站」完美收工。尽管「Next.js + AMP + Preact」的组合在其他非 AMP 项目中几乎不会用到，但文中提到的每一个坑想必其他团队也很难回避，希望本文能让大家少走点弯路。 最后，团队的共识很重要，除了能节约沟通成本，更多的是大家都知道要做什么、为什么去做，我们是在实现同一个目标 - 更好的用户体验。]]></content>
      <categories>
        <category>AMP</category>
      </categories>
      <tags>
        <tag>Webnovel</tag>
        <tag>AMP</tag>
        <tag>Google</tag>
        <tag>NEXT</tag>
        <tag>REACT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网文出海 • 书封自动化实践]]></title>
    <url>%2F2019%2F10%2F14%2F20191014%2F</url>
    <content type="text"><![CDATA[背景简介Inkstone 是一个面向海外原创作家和翻译的创作平台。大量的作家和作品，意味着大量的书封制作需求。这之前是需要设计师投入精力，或者花钱购买来解决的，淘宝的 5 元书封，说便宜也不便宜，和用户自己上传的书封一样，不保证版权方面没有问题，存在着各种风险。而此时浏览器端书封制作系统成为了我们解决这个需求的一大利器。作家只需要登录我们 I**nkstone** 「 海外作家创作平台 」，短短几步就能制作出一个精美的有版权书封。 海外书封系统主要分为纯色背景和图片背景两条线。纯色背景需要四步，图片背景需要五步就可以完成我们的书封制作。 这一切也早已在去年国内起点作家助手，张鑫旭老师带领下实现了中文版的书封制作系统。而我们海外测这边思路和国内是一样的，但是还是有很多非中文体系下的难点需要做额外的努力。 对于中文版书封系统，张鑫旭老师在他的博客上已经有很多相关内容给大家介绍。本文着重会在区别于国内书封的几个点地方给大家介绍： 书封分层逻辑 图片滤镜缓存机制 英文字体 英文分行 英文行高 英文对齐方式 文本颜色一、书封分层逻辑最开始拿到这个需求，第一反应就是将不同的图层对应成我们 DOM 的分层，然后直接将处理好的 DOM 导出为图片即可。虽然用 DOM 操作虽然对文本的处理会比 Canvas 优秀很多，但是在图像处理这一块还是 Canvas 可能性更高。比如要实现一个文字需要同时叠加图片纹理和背景颜色的这件事，基于 DOM 目前我好像也没有找到合理的解决方案。 所以选择了如上图所示的层级模式。背景层就是 Canvas 叠加滤镜之后的 Base64 图片，中间层是用 Canvas 直接绘制的文字「 书名 + 作者名 」，最上面一层是 LOGO 和水印的图片。 当用户点击上传按钮的时候，再用 Canvas 将这个三个层级叠加成我们想要的书封，提交到我们的服务器。 二、图片滤镜缓存机制 对于图片滤镜处理的相关技术方案大家可以去张鑫旭老师博客上搜索关键词：滤镜。这边会着重在滤镜缓存优化机制上给大家介绍。 为了体现优质的滤镜效果，和国内书封一样选择的是电影级别的 3D LUT 滤镜。可是这种级别的滤镜，大部分文件大小都接近 1M，如果在用户每次点击按钮之后，才去加载对应文件再渲染，这整个等待时间是很长的。并且更让我吃惊的是，渲染滤镜是一个可能比加载还要花时间的过程。 海外前端需要生成的书封的尺寸是 8101080，而这也就对应着 874, 800 个像素点，而这种 3D LUT 滤镜几乎是需要去处理每一个像素点，可想而知这整个计算量是非常大的。再看看我们在预览状态下的书封尺寸其实是只有 240320 的，用户在点击切换滤镜的时候，并不表示他一定会用这张图，有可能真的只是看看。 单位： ms 所以这边的处理方案是在预览状态下，只会去处理 480*640「 2倍图 」这个尺寸的书封。从上图可以看到我们整体的平均加载时间，减少了近 63% 的时间。 当用户真正点击上传的时候，才去对原始尺寸的图片做滤镜处理。而此时，因为滤镜文件已经加载过了，相当于只需要滤镜渲染的时间，一举两得。 然后我们再来看看预加载逻辑，当用户进入页面的时候默认是没有应用滤镜的。在这个时候会预先加载第一个滤镜，加载完成渲染，然后加载第二个滤镜，加载完成渲染。渲染好的图片会转成 Base64 的 URL，放到右侧 IMG 列表里「 这个列表在生产环境会隐藏 」。当用户点击切换滤镜按钮的之后，只需要从右侧列表中拿出对应序号的 URL，替换左侧的展示区域中的背景图片的 URL 即可。 这样做相当于我们总是先于用户两步，去尝试处理图片的滤镜效果。最大限度的减少了用户等待的时间。甚至当用户走完一圈之后，切换滤镜就等于交换两张 Base64 图片的 URL，没有加载，也没有滤镜处理，完美。 三、英文字体3.1 字体加载方案 国内对于中文字体的处理我们用自建字体服务 Y-font 「 阅文中文字体接口服务 」支撑，可以按需加载书封用到的几个文字的字体。但是海外和国内是不共享服务器的，导致于我们直接没法使用这套服务。不过好在和中文字体比起来英文字体本身就比较小，再加上 Google Font 的加持，即使全量加载也不会有太大的问题。 海外书封的字体列表本身还和用户选择的作品分类有关系。一开始我是给每个分类都准备了一个存放字体列表的 CSS 文件，当用户切换作品分类的时候，切换对应的 CSS 文件。然而后面发现这个是我想多了。 对于字体浏览器是有自己的处理逻辑了。简单的说就是，页面中如果没有任何一个文字设置了对应的字体，即使你引入了字体的 @font-face 这个字体也不会被加载。当你给某个文字设定了font-family 之后这个字体文件才会加载。当这个字体文件加载成功之后，这个设置了对应font-family 的文字会重新进行绘制。 所以最后我将不同分类的字体文件都合并成了一个，因为不同分类下的字体是有重叠的，反而让整体的字体 CSS 文件变小了。后续通过给文字设置 font-family 来控制字体的加载。 如图所示，我会在页面中直接输出用户选择分类下的字体列表，并只给前五个的文字设置font-family 也就是说我预加载了这五个字体。因为用户选择分类是在第一步，切换字体是在第最后一步，所以当用户到达第五步的时候，这五个字体可能早就已经预加载好了。 当用户切换字体的时候，我会从用户选择的字体序号开始，给后五个文字设置font-family，相当于用户真正切换字体的时候只加载一个字体「有四个已经预加载好了」。然后用户在这切换字体的整个过程中，也几乎不会感受到字体的加载。这个预加载逻辑和之前处理滤镜的方式如出一辙。 更值得一提的是，这种方式还解决了无法知道字体文件什么时候加载成功的逻辑。 3.2 字体渲染优化我们都知道存在 DOM 标签中的文字，如果是动态加载的字体，当字体文件加载好之后，设定了相关 font-family 的字体会自动重新渲染成对应的字体。 但是绘制在 Canvas 中的文字，在字体文件加载后，需要手动触发渲染。可是犯难的问题在于，我们如何才能知道一个字体文件是否加载成功？对于这个问题是有一个 「 Web Font Loader 」的库可以解决的。然而当我们采用了预加载五个字体的逻辑之后，这个库的意义就不大了。因为用户在切换字体的时候，下一个字体可能早就已经加载完成，也就不会出现当前字体动态加载的问题。 当然有一些极端的情况就是用户在切换字体的时候按钮多次点击，并且这个速度超过了我们预加载 5 个字体文件的速度。或者在某些网络相对没有那么好的地区，Google Font 加载比较慢。这个时候会出现当前字体对应不上「 会显示默认字体 」。对于这个问题我们的处理的方式是不处理。 因为用户其实并不知道哪个编号对应哪个字体，即使出现了字体编号和字体不匹配的问题，用户也是很难发现的，可能会以为这个编号的字体就是和默认字体长得很像。当用户点完一圈再次回来的时候，这个字体就很有可能加载好了。 四、英文分行4.1 canvas 文字绘制方式 1context.fillText(text, x, y [, maxWidth]); canvas 文本绘制API text：需要绘制的文本 x: 开始绘制的横坐标 y: 开始绘制的纵坐标 maxWidth：文本显示宽度（文本放不下会水平方向压缩） 用 Canvas 绘制的文本，并不会像 DOM 标签那样超出之后会自动换行。想要实现自动换行，需要手动计算，然后追行绘制。比如你有一行文字 你是我的小苹果， 文字大小是 16px，行高是24px，Canvas 画布的宽度是 4*16px。就需要将按照每行最大 4 个字为一组逐行绘制。 123context.font = &apos;16px STheiti, SimHei&apos;;context.fillText(&apos;你是我的&apos;, 0, 0);context.fillText(&apos;小苹果&apos;, 0, 24); 4.2 文字换行方案 图1 / 图2 / 图3 国内和海外书封，最大的不同就是对于文字的处理。而这不同的原因来自于中文和英文本身的差异。 简单的说就是中文可能一个成语搞定的事，英文需要一整句话。 所以多数情况下，作者的书名一行是放不下的。于是我们只能反向思考，基于画布的宽度，和一行文本的个数动态去计算文字的大小「 图1 」。 1字号 = 取整(画布宽度/一行单词个数); 当用户点击底部的空格区域添加换行符的时候，选取字数最多那一行作为我们上述公式的被除数，用来计算我们的基础字号，其它行也基于这个字号进行绘制。 当然我们计算的字号不可能会无限大，所以我们会给基础的字号一个最大值，当计算出来的基础字号超过这个最大值的时候，我们会以这个最大字号作为我们的基础字号「 图3 」。 然而这就会出现另外一个问题了，就是大多数的英文书名一行显示的时候，这个动态计算的文字的字号都偏小。这就直接导致，大多数用户在刚进入这个页面的时候，都会看到这个并不优雅的状态「 图1 」。 为了解决这个问题，在用户首次进入文字排版的页面时，会自动在文本正中间的最近的空格处，默认帮用户添加一个换行符。虽然并不是完美的解决，但至少能保证大多数的用户首次进入的文本可读性「 图2 」。也能告知用户，我们的交互形式是利用底部空格进行换行，是一个一举两得的办法。 五、英文行高1单行文字起始点纵坐标 = 基准点起点纵坐标 + 行号 * 行高； 前面有提到，我们在绘制 Canvas 文字的时候，还需要提供起始点的横纵坐标。在字号相等的情况下我们的起始点纵坐标只需要通过上述公式就可以实现。 1行高 = 字号 * 1.5; 本来一开始想通过这个公式来处理文字的行高「 这是网页中最常用对于行高的处理方式 」。然而在英文这个错综复杂的字体系列下，这个公式显得是那么的苍白。 因为英文不像中文那样是四四方方的，英文中有视觉上偏上的字母 「 l 」 , 也有视觉上偏下的「 g 」 。即使是同一个字体，同样的字号行高下，你也可以看到，第一列的文字发生了重叠，第二列显示还好。所以在大小写混排的状态下，我们是很难给到某一个具体到行高来规避这样的问题。 此时细心的同学可能发现，后面的两列因为都是大写好像这样的问题就好了很多。所以我们和设计师约定书封标题默认都是大写，然而问题还没有结束。 因为我们的字体用户是可以自由替换的。即使其它条件都一致的情况下，用户看到的效果仍然可能会是千差万别。 1行高 = 字号 * 1; 在经过多次的调整和视觉对比之后，我们最终选择了这个公式来作为我们行高的计算方式。当然这中间也麻烦设计师舍弃了一些特别违和的字体。 六、英文对齐方式 本来这个对齐方式如果只有左中右三种方式的话是没有什么好讲。因为 Canvas text-align API 自带这三种对齐方式。 难就难在第三个 AUTO 的这种对齐方式，这其实是一种类似海报中常用的艺术表现手法，上面的四个图都是在 AUTO 模式下，只是调整了文字的换行实现的。可以看到这个效果是比左中右这三种常规方式更加生动的「 为优秀的设计师点赞 」。 相信大家通过上面的示意图也可以看出其中的逻辑。就是我们每一行的字号是基于上一节提到的公式单独计算的。简单的说就是每行字数越少字号越大「 当然会有一个最大值 」。 1单行文字起始点纵坐标 = 基准点起点纵坐标 + 之前每一行的行高； 然而现在因为每一行都是单独计算，所以每一行的字号都不一样，对应的行高也不一样，就得把所有行高都纪录下来，在逐行绘制。所以在 AUTO 模式下文字起始点的纵坐标就变成了上述公式。 七、文本颜色7.1 取色方案 图1 / 图2 对于文本颜色，一开始我以为，只需要设计师给我一个文字颜色列表就可以了。然而事实还是想得太简单了。 比如设计师给我的颜色列表第一个颜色是白色，当用户选择了如图2那种偏向纯白的背景，如果还是用白色作为我们文字的颜色，就几乎看不清的。所以我们需要有一个逻辑去针对不同的背景切换默认的文字颜色。 这边给大家推荐的一个库是 Color Thief。如上图所示，就是给这个库的 API 提供一张图片，它就会返回给你这张图的配色表。并且这个配色表的长度你是可以定制的。 1const isWhite= (r + g + b) / 3 &lt; 128*1.3? false: true; 我们怎么基于这个库去判断一个背景图是偏深还是偏浅呢？很简单，我们取出这个配色表的第一个颜色，也就是这张图片中的主色。让后将这个颜色的 rgb 的色值取一个平均值，如果这个平均值小于 128*1.3 我们就近似认为这个图是偏深。大家可能会问，128 不才是256 的一半吗 ？为啥我们这里还要再乘以 1.3 。 其实这个很简单，在 rgb 平均值在 128 附近的时候，白色和黑色文字其实都是可以看得清的。但是在这个边缘，我们更希望用户是看到的是白色文字。至于为啥是 1.3，其实就是我们自己一张图一张图去试，大概觉得在这个阈值下，比较符合我们期望的效果。 这里 Color thief 对于图片配色表的计算和之前滤镜逻辑有着类似计算逻辑，就是我们提供的图片尺寸越大，这个计算的时间就会越长。本来我们这里要的就是一个模糊的值，所以我们提供给 Color thief 的也是一个缩略图。 7.2 颜色列表到了这里，我们只是粗略的解决了用户字体设置页面的默认字体颜色问题。对于整个颜色列表要怎么设置也是一个问题。 1文字颜色列表 = 黑+白+8个配色+4个百搭颜色 我们用 Color thief 取整个图片的 9 个配色，然后用第一个颜色作为我们评判默认文字颜色是黑是白的标准。然后加上剩于的 8 个配色和设计师给到的 4 个百搭的颜色，组成我们的文字颜色列表。 大家可能会好奇，这里为啥我们直接用背景的配色作为了我们文字的颜色？这个方案是，张鑫旭老师在国内书封项目中提出的。 不难理解，就是图片配色里面的颜色和图片本身搭配才不会有太大的违和感。其它的颜色，有可能单独看会很好看，但是放到一个不搭的背景里面反而会显得奇怪。所以后面设计师给到的颜色也是选的比较百搭的颜色。 视频演示 总结篇幅关系，这边着重挑出了几个我认为值得给大家分享的技术难点。另外还想给大家分享的是一点点项目心得。 刚拿到项目的时候，其实我最担心的是图片的滤镜和图片纹理的叠加不知道要怎么实现。因为这部分在我之前的项目经验里面是空白。然而在我实际使用的时候，这部分其实基本上就等同于调用一下 API 而已，当然这个和因为有张鑫旭老师的加持也有很大的关系，几乎这方面的问题都能在他的博客中找到。真正比较难的还是在想要提升用户体验这个点上。 一开始因为自己的一些既定思维，误以为在浏览器端处理英文应该会比中文容易很多。毕竟中文字体动辄几兆的文件大小在那儿摆着。然而在实际开发中，才知道因为英文语言特性，对于这种需要精细化处理的地方会有很多的坑。简单的说，在某种字体下，你这整个逻辑都可能被推翻。在这一点上，可能还是要略微舍弃技术追求，和设计师商量，看看是否可以舍弃掉这样的字体。 技术永远只是你从 A 点到 B 的的工具。到达 B 点才是你核心的目的。]]></content>
      <categories>
        <category>REACT</category>
      </categories>
      <tags>
        <tag>Webnovel</tag>
        <tag>书封</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非常规 - VUE 实现特定场景的主题切换]]></title>
    <url>%2F2019%2F08%2F15%2F20190815%2F</url>
    <content type="text"><![CDATA[实现页面皮肤切换，常见的方案有几种：替换 css 链接、替换 className、改变 css 原生变量值、使用 less.modifyVars、props 参数下发等；不同的业务场景，我们一般会选择不同的方法来实现目标。最近在公司运营活动平台上的主题功能的实现 ，我们尝试了一种新的解决方案，实现了页面主题的切换，目标是为了提高项目的可维护性、可扩展性，以及降低接入复杂度。 “主题”需求在了解主题功能之前，我们先来解下业务场景：在运营活动后台中，编辑活动配置页面，拖拽选择所需对应组件，并设置组件相应配置项，点击保存，既完成活动页面发布活动，前台就能访问对应生成活动。编辑页面如下图： 在如上前提，我们的需求就是：在运营后台配置页面中，实现全局切换主题功能，具体需求如下： 在配置页面，初始化页面时，实现主题一键切换所有组件的样式； 页面中的组件的配置，可配置对应组件样式，覆盖主题样式； 再次点击设置主题，可以覆盖已经设置样式的组件样式； 实现效果如下图所示： 那在了解完需求之后，对于 VUE 项目，要实现主题功能，一般想到的实现方式就是 theme 参数通过 prop 下发来实现。那我们就先来聊下常规实现方式：prop 下发实现方式。 常规实现方式定义主题首先我定义 theme.js 为主题相关参数，如下：12345678910111213141516const DEFAULT_THEME = &#123; primary: &apos;#2F54EB&apos;, subPrimary: &apos;#D6E4FF&apos;, error: &apos;#F5222D&apos;, success: &apos;#52C41A&apos;, warning: &apos;#FAAD14&apos;, background: &apos;#FFFFFF&apos;, text: &apos;#222222&apos;&#125;export default &#123; DEFAULT: DEFAULT_THEME, FIRST: &#123; ...DEFAULT_THEME, background: &apos;#2590ff&apos; &#125;&#125; 主模块下发 theme 给予组件接着需要在主模块中，下发 theme 参数，和组件相关配置参数 给到组件，点击按钮，切换主题：123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;div @click=&quot;changeTheme&quot;&gt;换主题&lt;/div&gt; &lt;Component v-for=&quot;(item, index) in componentList&quot; :theme=&quot;theme&quot; :key=&quot;index&quot; ...item.config // 业务相关参数都在config中 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import theme from &apos;theme.js&apos;export default &#123; name: &quot;themeChange&quot;, data() &#123; return &#123; theme: theme[&apos;DEFAULT&apos;] &#125; &#125;, methods: &#123; changeTheme() &#123; this.theme = theme[&apos;FIRST&apos;] &#125; &#125;&#125;&lt;/script&gt; 组件监听 theme 改变组件样式组件中，获取上级组件传递下来的配置参数及主题参数，并监听 theme 的变化，当发生改变，重置样式参数值为主题样式：12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div&gt; &lt;div :style=&quot;&#123; background: config.bgColor &#125;&quot;&gt;主题&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import theme from &apos;theme.js&apos;const initTheme = theme[&apos;DEFAULT&apos;]export default &#123; name: &quot;themeSwitch&quot;, props: &#123; theme: &#123; type: Object, default: () =&gt; (&#123;&#125;) &#125;, bgColor: &#123; type: String, default: initTheme.background &#125;, ... &#125;, data() &#123; return &#123; config: &#123; bgColor: this.bgColor, ... &#125; &#125; &#125;, watch: &#123; &apos;theme&apos; (to, from) &#123; this.config.bgColor = this.theme.bgColor &#125; &#125;&#125; &lt;/script&gt; 看到这里大家会说，为什么需要在** **watch 中监听主题的变化，而不是在组件初始化的时候参数就直接指向主题对应的参数呢？ 因为主题需求里面所说的，在组件里面也是可以改变组件相关样式的，上述 demo 代码中的 bgColor 参数，既可以通过点击切换主题可以设置 ，也可以是组件自己设置的，有多个来源（这里不对组件的配置实现做详细展开）；要做到设置主题的时候，组件的样式会设置相应的主题色，就需要在 watch 中进行监听 theme 参数的变化，发生变化，重置相应参数，但是这种方式在每个组件都需要有相同代码片段，监听参数，达到我们的效果，代码非常冗余。 综上，我们对代码进一步优化，把监听 theme 参数的方法统一封装，这里会有另一个问题：每个组件对应颜色的参数是不可定的，且参数层级也是不可定的，几乎每个组件需要维护一整个变量数组。这样定义的规则会相对复杂，维护成本过高，且极易弄错。 很显然这样的实现方式并不是一种很好的方法，那要如何实现？ “非常规”实现方式在尝试上面的方式之后，我在想我的思路是否正确，是不是切入角度有点问题，那我们换一个角度去切入。 配置参数入手当我**们发现页面整个 this.componentList 参数 ( 里面存储了所有组件的相关配置 ) 我是可以拿到的时候，我们**是不是可以从数据入手？ok，说到这里，那其实思路就出现了, this.componentList 里面的参数规则：1234567891011[ &#123; componentName: &apos;xx&apos;, config: &#123; color: &apos;xxx&apos;, background: &apos;xxx&apos;, ... &#125; &#125;, ...] 我们会发现，在开发组件的时候就已经是把颜色相关参数提取到配置里面了，那也就是说我修改配置参数的值，其实就可以达到设置主题的效果？因为所有组件的配置参数都是由this.componentList 参数下发的。 参数给予特殊标识定义 theme.js 相关参数，和上面一致，故不在多说，主要做的就是，在组件中，我们把相关参数进行修改，改为有特殊标示的参数， 如下：1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;div :style=&quot;&#123; background: this[&apos;bgColor.t.background&apos;]&#125;&quot;&gt;主题&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import theme from &apos;theme.js&apos;const initTheme = theme[&apos;DEFAULT&apos;]export default &#123; name: &quot;themeSwitch&quot;, props: &#123; &apos;bgColor.t.background&apos;: &#123; // .t.: 为特殊标识 ；background: 为主题里面对应的字段名 background: &apos;#FFFFFF&apos; type: String, default: initTheme.background &#125; &#125;&#125; &lt;/script&gt; 遍历参数替换特殊标识参数值当点击主题切换的时候，会去遍历 this.componentList 参数，修改有特殊标示的参数为新主题对应的参数，代码如下：123456789101112131415161718192021222324252627282930313233/** 根据主题重制componentsConfig* @method changeTheme* */changeTheme () &#123; this.theme = theme[&apos;FIRST&apos;] this.componentList.forEach(component =&gt; &#123; this._setThemeChangeConfig(component.config || &#123;&#125;) &#125;)&#125;,_setThemeChangeConfig (obj) &#123; Object.keys(obj).map(name =&gt; &#123; if (Object.prototype.toString.call(obj[name]) === &apos;[object Object]&apos;) &#123; this._setThemeChangeConfig(obj[name]) &#125; else &#123; const themeColorArr = name.match(/\.t\.(\S*)/) if (themeColorArr &amp;&amp; this.isThemeColorName(themeColorArr[1])) &#123; this.$set(obj, name, this.theme[themeColorArr[1]]) &#125; &#125; &#125;)&#125;,/** 判断颜色name是否在主题里面* @method isThemeColorName* */isThemeColorName (name) &#123; let has = false Object.keys(this.theme).forEach((paramsName) =&gt; &#123; if (paramsName === name) has = true &#125;) return has&#125; 最终实现了最终的主题切换的效果。 该方式带来的优势： 对组件代码几乎无侵入性，组件只需要修改样式相关参数带上特殊标示既可，规则相对简单； 参数无需一层层下发，易于维护； 主题与主线功能相对独立，可以轻易移除主题功能，项目也可以正常运行； 总结主题的实现，不管是常见的方式，还是上述项目中的主题的实现方式，我们往往需要了解业务特性，去寻找最合适的解决方案。不同项目，有不同的实现方式，但目标都是为了提高项目的可维护性、可扩展性，以及降低接入复杂度。 项目目前的实现方案，尚不失为一个好的解决方案，或者可以作为一种新的思路，供大家参考。]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>主题</tag>
        <tag>运营活动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 AMP Story，你需要知道这些]]></title>
    <url>%2F2019%2F05%2F22%2F20190522%2F</url>
    <content type="text"><![CDATA[在我们的 AMP 改版 过程中，我们发现了一些新的 AMP 组件，并针对部分组件做了一些尝试。其中就包括 AMP Story。AMP Story 是 AMP 的一种新的网页展现形式。 成果展示在介绍 AMP Story 之前，大家可以先看一下，我们基于 AMP Story 技术做的一个 Demo 页面。下面是我们做的一个关于 Tour Of Wenbovel 主题的一个 AMP Story 页面。对用户来说，与传统的单纯文字和图片不一样，它提供了一种沉浸式的 Web 体验。 「Webnovel 的 AMP Story 页面，Tour of Webnovel」 AMP StoryAMP Story 是 AMP 在推的 4 大主类之一，另外三个分别是 AMP Website、AMP Ads、AMP Email。之前我们都是着重于 AMP Website 这一方面的工作。AMP Story 在展现形式上类似于我们熟悉的 ppt，同样是文字和图片搭配，加以丰富动效和页面切换。但除此之外，AMP 团队为我们实现了更多组件细节。比如页面切换时的贴心提示，告诉用户左右切换的点击区域；比如 pc 端到移动端的样式适配；比如社交网络分享功能，我们不需要再自己集成各个社交网络的分享；他们甚至为 AMP Story 单独做了一套沉浸式的广告组件。 为什么要做 AMP StoryAMP Conf 2019 上的一个分享「Boring Content - Excited Users」令人感触颇深：Boost 是一个让用户比较、选择数百种不同运营商流量包的产品。他们的用户主要是非洲、印尼、东南亚的年轻人，对新技术有很强的适应能力，喜欢新颖的东西。他们原来使用博文的形式来介绍、比较各种流量包，但效果并不好，因为内容无法引起用户的兴趣。于是他们改用了 AMP Story，这种动感、图文并备的形式，让他们的内容阅读完成率提高到了 87%。 「boost 的两种推文形式对比，图片摘自演讲视频」 在信息爆炸的时代，人们越来越难以集中注意力，面对一整屏密密麻麻的文字时的通常状态是：一目十行地随意浏览，寻找关键信息，机械地滑动屏幕并假装自己看完了。这也是为什么总是会有“太长不看”的吐槽，也是为什么信息碎片化的社交网络、抖音这样的沉浸式短视频应用会轻而易举地攫取用户的芳心甚至让用户上瘾的原因。上面提到的 Boost 案例也印证了这一点。东南亚、非洲，这些地区拥有大量的远高于桌面的移动用户，他们喜爱在 Youtube 上看视频，喜欢刷 Facebook，Boost 的成功之处正是顺应用户心理作出改变。AMP Story 作为一种新的网页信息展现方式，跳出了传统的文字为主的垂直的文档流页面，让更加生动的图片、短视频等进行自我表达。而我们也可以借机思考——现有的一些页面是否能吸引用户的注意力，用户是否能有效地消化我们传达的信息，将来我们的用户会喜欢如何获取信息等等，并快速作出一些改变、尝试。 开发的基本流程开发 AMP Story 不是一件很困难的事情，官方提供了详尽的文档和丰富的案例。但在开发之前，我们还要思考内容迁移。如果你的内容是一个榜单或一个列表，那就十分简单。但如果不是，你就要考虑如何把你的内容井井有条地分解，然后大量地删减文字，只留下最核心的思想，搭配相应的图片、视频资源，从而更加直观而有力的表达，或营造氛围。 「Understanding the parts of an AMP story by AMP」 上图展示了 AMP Story 的三个层级：Pages、Layers、Elements。按这个结构搭好页面框、指定 layer 的布局（Fill、Vertical、Horizontal、Thirds）、往里塞一些需要的组件（文字、图片、视频等等）并给组件加上动画，就可以完成一个最简单的 Page。以我们的第二个 Page ，也就是除 cover 外正文的第一个 Page 为例，它的结构如下：123456789101112131415&lt;amp-story-page id=&quot;page2&quot; class=&quot;page&quot; auto-advance-after=&quot;video2&quot;&gt; &lt;amp-story-grid-layer template=&quot;fill&quot;&gt; &lt;amp-video id=&quot;video2&quot; layout=&quot;fill&quot; src=&quot;//www.yueimg.com/overseam/img/amp/story/webnovel_02.mp4&quot; poster=&quot;//www.yueimg.com/overseam/img/amp/story/poster_02.jpg&quot; autoplay&gt;&lt;/amp-video&gt; &lt;/amp-story-grid-layer&gt; &lt;amp-story-grid-layer template=&quot;vertical&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;div animate-in=&quot;fly-in-right&quot; animate-in-duration=&quot;0.2s&quot; animate-in-delay=&quot;4s&quot;&gt; &lt;div class=&quot;pin-bottom&quot;&gt; &lt;h2&gt;Cultivation Chat Group&lt;/h2&gt; &lt;p&gt;One day, Song Shuhang was suddenly added to a chat group with many seniors that suffered from chuuni disease...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/amp-story-grid-layer&gt;&lt;/amp-story-page&gt; 这个 page 的效果如下： 如此炮制出封面和其他 page，再加上书末页（我们会在后文详细说明），你的整个 story 就基本完成了。 「封面和书末」 开发 tips 集成 和 由于 AMP Story 整套的层级十分严格——比如说 body 下只能有一个 子元素。因此我们很难像正常的代码那样在逻辑合理的位置插入必要的 以及 组件。我们的解决方案是这样的：将 放在 下，它应该是 除了 外唯一能容纳的组件； 则无法放在这里，于是我们将它放在了第一个 page 下的单独一个 layer 中，其他用法则没有什么区别。1234567891011121314151617181920212223242526272829&lt;amp-story standalone&gt; &lt;amp-analytics type=&quot;googleanalytics&quot; id=&quot;analytics&quot;&gt; &lt;script type=&quot;application/json&quot; data-ignore=&quot;true&quot;&gt; &#123; &quot;vars&quot;: &#123; &quot;account&quot;: &quot;UA-xxxxxxxx-x&quot; &#125;, &quot;triggers&quot;: &#123; &quot;default pageview&quot;: &#123; &quot;on&quot;: &quot;visible&quot;, &quot;request&quot;: &quot;pageview&quot;, &quot;vars&quot;: &#123; &quot;title&quot;: &quot;&#123;&#123; page.title | safe &#125;&#125;&quot; &#125;, &#125; &#125; &#125; &lt;/script&gt; &lt;/amp-analytics&gt; &lt;amp-story-page id=&quot;page1&quot; class=&quot;page&quot; auto-advance-after=&quot;video1&quot;&gt; &lt;amp-story-grid-layer template=&quot;fill&quot; &gt; &lt;!-- invisible things --&gt; &lt;amp-install-serviceworker src=&quot;https://m.webnovel.com/sw.js&quot; data-iframe-src=&quot;https://m.webnovel.com/installServiceWorker&quot; layout=&quot;nodisplay&quot;&gt;&lt;/amp-install-serviceworker&gt; &lt;!-- invisible things end --&gt; &lt;/amp-story-grid-layer&gt; ... &lt;/amp-story-page&gt; ...&lt;/amp-story&gt; amp-story-bookend 小技巧 是 AMP Story 的结束页组件，当用户播放完所有的 page 后，就会看到这样一个弹层，将用户引流到相关的链接、引导用户分享等等。这个弹层的样式和交互是固定的，我们需要通过一个 json 来定制其内容。官方的使用案例是外链一个 json 文件：1&lt;amp-story-bookend src=&quot;path/to/my/bookend.json&quot;&gt;&lt;/amp-story-bookend&gt; 但将这样一个最多只有十几行的 json 单独提取一个页面，我的内心是拒绝的，毕竟文件的管理、缓存、更新都更加麻烦。其实官方也实现了内嵌的写法，只是并未在文档中特意指出，具体可以查看这个 issue。于是我们可以愉快的这样写⤵️，如果是服务端渲染，还可以用代码生成相关内容。12345&lt;amp-story-bookend&gt; &lt;script type=&quot;application/json&quot;&gt; /* bookend JSON goes here */ &lt;/script&gt;&lt;/amp-story-bookend&gt; 善用模板 如果你的大量内容形式趋同，大可以通过模板抽离出可复用的框架，定制其中的样式、动画组合、资源内容等等，减少样板代码。 最佳实践经验完成一个 AMP Story 是十分简单的事情。但是要做一个出色的 story 却并不简单。AMP 团队给出了一些关于 AMP Story 的最佳实践，结合我们自身的经验，可以大致从这四个方向来优化。 沉浸式体验 「Space Photos of The Week by the Wired」 沉浸式体验的一般做法就是全屏。比起只在页面中划分一小块来展示图片或者视频，全屏能展示更多细节、减少干扰，让用户集中注意力。 当页面的主要资源是视频时，可以自动播放视频。如果是连续的视频，可以在播放结束时自动切换至下一页。 易于阅读 「The Amazon Gold Rush by the Atlantic」 确保中心突出、文字简练。突出关键信息（如标题）的方式很多，比如为文字单独加上背景颜色。 正文字体大小应不小于浏览器推荐的最小字体 16px。 注意图文的关联性。 在背景是图片或视频的前提下，可以在中间放置一个蒙层，保证文字阅读不受影响杂乱背景的干扰。 注重弱网体验 提供视频的首帧作为 poster，同时从中截取主色作为该页的背景色，这是为了让页面上的文字保证可读，同时让整个加载过程流畅过渡。 每页视频一般不超过 10s、4Mb，否则可能导致过长的加载时间。 体验的丰富性和整体的协调性 「beyonce-rule-the-world by USA today」 一方面，我们可以加上动画来使页面更加动感、富有韵律，或者通过视频实现一些创意效果，给人留下深刻的印象。另一方面，我们不应该滥用动画，一股脑地把能加的东西都加进来而不考虑协调性自然是不可取的操作。如果觉得难以把握这个度，可以向设计师寻求帮助。或者参考 AMP story 主页上的优秀案例。 实用工具AMP Story 从形式上强制优化阅读体验，促使内容生产者创造出更加直观、生动的内容，而不仅仅只依靠文字。但是对开发者来说，有限的施展空间导致 AMP Story 的开发偏向模式化。因此，我们可以使用一些 AMP Story 的辅助工具来加速其生产流程。 makestories.io ：这个网站提供许多 AMP Story 的模板，支持可视化制作 AMP Story，解放程序员的🤲。 Wordpress 插件：同上，可以可视化制作 AMP Story。 Jumprope：制作步骤类型的视频，可作为 AMP Story 的素材。 Unfold：制作图片、文字拼贴，可作为 AMP Story 的素材。 AMP Story 的更多可能性AMP 团队也在不断为 AMP Story 添砖加瓦，让它具备更多可能性。下面是一些笔者觉得很赞的点： Localization：将你的内容语言自动翻译成其他国家的语言，并适应其语言方向（比如阿拉伯语就是从右到左的）。 sidebar：加强跟主页联系，AMP Story 不再是一个孤立的页面。 内嵌第三方插件：例如 Twitter 内嵌、Google Map 内嵌、Youtube 视频内嵌等等，一个线下实体店铺推荐的 story 就可以加入 Google Map 内嵌。 附件：给部分 page 一个了解更多的下拉选项，即可加载非 AMP Story 页面的内容。 Google Search 中的优化：在 Google Search中开辟了新的位置专门用于展示 AMP Story，生态的构建也是十分重要的一环。 amp-story-ad：AMP Story 独有的广告组件，作为单独的一个 page 插入在 story 中，兼顾了体验上的无缝、和谐。你看，AMP 团队甚至考虑到了广告，可见其打造生态闭环的野心。 总结作为 AMP Story 的消费者，用户可以获得更加丰富的体验。而作为 AMP Story 的 publisher，AMP Story 完全可以让我们集中于内容的创造，减少了大量开发的成本。我们无需考虑组件的实现方式、各种屏幕下的内容完整程度、不需要再手动集成分享的功能，只需要在 AMP 最佳实践的基础上，致力于真正的目标。而 AMP Story 日渐完善的生态，包括 SEO 的红利和其广告收益也都十分值得我们去尝试。]]></content>
      <categories>
        <category>AMP</category>
      </categories>
      <tags>
        <tag>Webnovel</tag>
        <tag>AMP</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 AMP，Webnovel 都做了些什么？]]></title>
    <url>%2F2019%2F05%2F14%2F20190514%2F</url>
    <content type="text"><![CDATA[引言AMP 是什么？它全称 Accelerated Mobile Pages 「AMP」，是 Google 推出的一个加速网页加载的开源框架，我们在此也不做太多的介绍，具体可以看我们之前发的公众号文章。阅文前端团队作为国内最早践行 AMP 的开发团队之一，我们的 AMP 实践也经历了好几个大迭代，其成果也得到了 Google 官方的肯定，分别在 Google I/O 2019 和 AMP Conf 2019 大会上被 feature（图1-1），希望我们积累的经验可以给大家提供帮助。 「图 1-1：阅文集团在 Google I/O 大会、AMP conf 2019 被 feature」 Webnovel with AMP是否值得去做？目前 Webnovel 先后进行了 2 次 AMP 页面的转化。首次 AMP 的实施输出了站点的 2 个主要着陆页：首页、详情页，上线后 1 个月 Webnovel 的阅读页 PV 提升了 59%，可以归功于 AMP 详情页的转化。第二次我们则将 Webnovel 主要路径页面进行了 AMP 的转化（阅读页、书库页、漫画详情页、漫画阅读页等），目前从 Google Analytics「GA」的数据来看，还是非常值得去实施的 ：这些 AMP 页面平均加载时间为 0.94s， 而被 AMP Cache 缓存的页面加载时间甚至为 0。 我们做了哪些?AMP 不仅是一个前端技术框架，它还提供了一套完整的生态，包含一系列 ”服务于“ 页面加载体验的规范和约束，其核心思想是，构建出加载速度更快甚至达到秒出的页面，这要归功于它提供的 3 个重要组件： AMP HTML - 提供了一系列 AMP 自定义的 HTML 标签及规则，有效地保证了 HTML 的加载体验。 AMP JS - 提供了一系列 JS 组件，其资源直接来源于 Google CDN。 为了达到极致的加载体验，AMP 并不允许开发者引入自定义的 JavaScript，而是提供了大量的 AMP JS 组件来实现用户想要达到的效果（ AMP Conf 2019 新引入的 amp-script 可以帮助解决自定义组件不能完成的效果，不过当前这个功能还在实验当中）。 AMP Cache - 利用 Google 的缓存及预加载方案可以达到页面的秒出。 那么用户体验与开发体验是否可以达到能够接受的平衡点？我们先来看看 Webnovel AMP 具体的实施细节吧。 AMP HTMLWebnovel 的 AMP 页面采用了 EJS 模板引擎作为直出方案，和普通的 EJS 项目唯一的区别就是需要遵循 AMP HTML 的一些规则。AMP HTML 提供了简单的 HTML 模板，并对一些 HTML 标签进行了规则的约束，只要遵循它的文档说明，还是能够很快接入的。当然，Webnovel with AMP 最重要的实施步骤则是应用它的组件， 也就是「AMP JS」。 「图 1-2：AMP HTML 模板」 「图 1-3：AMP HTML 标签的规则」 AMP 组件的约束在参加 AMP 会议之前，我可能会说，这里需要先给各位打个预防针啦！在 AMP 的世界里，你不能够引入自己的脚本、不能外链引入自己的样式，只能一切按它的规则走！但此次 AMP 会议出乎意料地带来了一个新的技能 - amp-script 的支持，我们终于可以写自己的脚本了！但需要注意的是，amp-script 仅允许解压后最多 150KB 的大小，虽然如此，我们也可以方便地利用其异步加载一些我们自己的脚本。但为什么 AMP 对脚本有很多约束？来看下 AMP 的官方文档中关于脚本的说明： “JavaScript is powerful, it can modify just about every aspect of the page, but it can also block DOM construction and delay page rendering (see also Adding interactivity with JavaScript). To keep JavaScript from delaying page rendering, AMP allows only asynchronous JavaScript. AMP pages can’t include any author-written JavaScript”（即：JavaScript很强大，它可以改变一个页面的任何方面，但它同时也阻碍了 DOM 的生成、页面的渲染。为了避免它对渲染的阻碍，amp 仅仅允许异步加载 JavaScript，但它并不允许引入任何页面作者写的脚本） 脚本可以阻碍渲染，而为了保证快速呈现页面内容，脚本的约束似乎不可避免，对于 amp-script 大小的限制，也是为了保证在低端手机上依然有不错的加载体验。 AMP 组件的基础应用AMP 提供了超级多的组件，只需：1、外链引入该组件提供的 JavaScript 脚本。2、找到组件示例代码、嵌入 HTML DOM 结构中，按需更改组件参数。 「图 1-4 组件一览表」 AMP 文档中，每个组件基本都有具体的示例代码， copy 下来就可以在项目中使用，这一点很赞！但想要非常 “精准地” 实现我们想要的交互效果，还是非常难的，毕竟这个组件不是我们自己写的，我们也不能够拓展它，这种感觉就好比我们有手有脚、却只能用假肢，身体变轻盈了，但行动受到了很大的限制，不过比较欣慰的是，AMP 的常用组件也基本满足了我们的需求。这里例举了一些 Webnovel 使用的 AMP 常用组件： amp-img 遵循 AMP HTML 的规则，所有的图片都需要用 实现，它用于响应式地展示图片、并完美自带懒加载功能（不在视区内不进行加载）。目前 Webnovel 的漫画阅读页，所有的图片都用其实现了宽度 100%、高度自适应（图1-5）。「图 1-5：amp-img 轻松实现图片高度自适应」 在此之前我们是将图片绝对定位，同时在容器上添加样式「padding-top：图片宽高比 」来实现的，相比之下 &lt;amp-img&gt; 更方便： 「图 1-6：旧的实现方式」 「图 1-7：使用设置 layout 为 responsive 即可」 amp-list 目前我们大部分 AMP 页面都使用了这个组件，只要是异步加载某些模块，就会有它的用武之地（图 1-8）： 书详情页 - 打赏信息、标签信息、书评的异步加载。 漫画列表页 - 分页加载漫画书籍 漫画阅读页 - 分页加载漫画章节图片 「图 1-8：详情页、漫画阅读页、漫画列表页 amp-list 异步加载模块」 amp fallback &amp; placeholder 非常赞的 API ！有了它，我们无需检测加载失败、加载超时的情况，只需设定好该情况对应的 UI 展示即可！amp-img、amp-list 等组件中，只需在组件内的 DOM 元素标签上添加 fallback &amp; placeholder 属性即可。 amp-mustache 提供 mustache 模板引擎，一种 logicless「弱化数据逻辑」 的模板语言， 通常配合 amp-list 等异步加载组件来使用，amp-list 发起请求拿到数据后，会渲染其中的 mustache 模板、完成数据、模板的拼接。 amp-sidebar 用于侧边栏、工具栏等。目前我们左侧滑出的侧边栏就是利用它实现的（图 1-9），实现成本很低，只需将其对应的 DOM 结构放置于 body 下，同时在触发侧边栏展示的元素上绑定 AMP 提供的 tap 事件。「图1-9：amp-siderbar 实现侧边目录」 amp-bind 可配合 amp-state 使用，amp-state 组件用于初始化 json 数据，而 amp-bind 可以绑定数据到 DOM 元素上，同时支持 amp.setstate()、 amp.pushstate() 等方法实现数据的更新。目前页面中需要动态展示的元素、文本，我们通过它绑定了数据、数据改变后页面对应的元素、文本也会对应地变成绑定的数据。比较局限的方面是，只有在触发事件后数据才会生效，不适用于页面 onload 时的数据逻辑处理。 AMP 的事件机制 AMP 也支持事件的处理，例如 tap 点击事件、change 事件等，更高级的有：滚动到某位置触发动画等效果，具体可参考 AMP 文档。 AMP CacheAMP Cache 算是 AMP 的核心概念了，简单来讲，通过 Google 搜索引擎搜索到的 AMP 页面可以被 AMP 缓存，同时也会被 Google 进行预加载，Google 使用的一些安全性机制、缓存更新机制，可以让开发者更无忧地使用。AMP 也提供了被缓存页面的 CDN 地址拼接规则，利用这个缓存优势，Webnovel 将所有 AMP 页面之间的跳转链接改为了 AMP Cache 的地址，如果所有 AMP 页面都成功被 Cache ，那么页面之间几乎可以做到无缝切换（图 1-10），如果页面没有被 Cache，也不用担心会跳转到未知的 404 页面，因为 AMP Cache 会将其重定向到我们自己站点域名下的 AMP 页面。 「图 1-10：利用AMP Cache实现 AMP 页面无缝切换」 Webnovel AMP 页面的体验优化漫画阅读页多个 AMP 组件结合使用打造更好的交互体验Webnovel 漫画阅读页提供了另外一种不同于小说的阅读方式，由于漫画的阅读相比于小说更为方便快捷，因此其加载体验变得尤为重要，这里 Webnovel 利用 AMP 组件对漫画阅读页的加载体验做了优化，原本「刷新页面」切换章节的体验优化为「无刷新」加载章节内容。 amp-list、amp-form、 及 amp-state 合力实现无刷新向下加载除了服务端渲染的首章节，其它的章节内容若要实现异步加载，amp-list 组件是必然要用的，需要注意的是，如果其 src 参数为接口地址，那么页面 onload 时就会触发，但我们希望做到的是点击下一章再进行加载，因此实现方案为： amp-state 组件初始化章节模板所需 json 数据（图 2-1），其 id （例如 comicContent）可看作该 json 数据的变量名。 amp-list 去除 src 参数，改为 [src] 参数，其值为上一步的 comicContent（图 2-2）。 添加 amp-form 组件，其 action 参数值为下一章节的接口地址，同时参数 on 中处理表单提交成功的逻辑（图 2-3）， 即：获取数据后更新章节数组，这将会重新渲染 amp-list 中的章节模板。「图 2-1: amp-statue 初始化的数据」 「图 2-2: amp-list 中绑定 amp-state 中的数据」 「图 2-3: amp-form 的成功回调」关键点： amp-state 中定义的章节数据需要前端自己维护一个数组（图2-1中的 chapters 字段）来存储各章节，实现 amp-list 中循环渲染章节模板，展示所有加载的章节。 amp-form 中的 submit-success 逻辑中，需要通过 AMP.setState() 更新章节数组，将最新章节 push 进数组。 amp-form 中的 submit-success 回调仅仅是接口请求成功的回调，请求成功不代表业务逻辑中也是成功的，因此需要通过业务接口成功与否的标识字段再次区分成功和失败的逻辑。 amp-state 最多存储 100 kb 的数据，前端需要处理加载章节过多的情况，例如缓存当前加载的章节数，若超过一定数量，点击下一章刷新页面。 最终实现出来的效果：「图 2-4：无刷新加载下一章漫画」 小说阅读页 amp-list 组件进阶应用在上一节中，通过 amp-list、amp-form、 amp-state 3个组件的结合使用，终于实现了无刷新加载下一章，其实 amp-list 近期已提供实验性高级 API: load-more 及 load-more-bookmark 等参数，可以做到无限加载，并同时支持点击加载、无限滚动加载2种方式，无需前端自己维护章节数组，所有的一切都由 amp-list 自己实现。这里对小说阅读页进行了实践。 amp-list-load-more 实现无限滚动加载amp-list-load-more 的实践非常简单，只需在 amp-list 组件中，加入 load-more、load-more-bookmark 参数即可（图2-4），具体 api 说明可参考 amp-list 的文档。虽然当前功能为实验性功能，但相信 Google 不久后就会在正式环境进行支持。 「图 2-4：amp-list-load-more 代码片段」 由于 amp-list-load-more 是 AMP 的实践性功能，除了添加参数，还是需要做些准备工作的。 正式环境中，需要在小说阅读页的访问地址域名下（webnovel.com 或 AMP cache 的 Google 域名）种一个 Cookie（name: AMP_EXP，value: amp-list-load-more）才可体验此功能。 load-more-bookmark 参数只能为章节返回数据中的字段名称，其值必须为下一章的接口地址，不支持前端自己拼接地址，因此需要后端配合添加此字段。 接口返回的下一章 url 不能为相对路径，必须为带协议头、自己站点域名的 url，否则在 Google 域名下请求地址的域名会出现问题。 最终实现效果： Webnovel 更多的 AMP 实践当然，Webnovel 不只用了上文中提到的 AMP 基础组件，也没有止步于组件级别的体验优化，Webnovel 还使用了 AMP 主推的一些王者功能。 更优的体验 - AMP 主推功能的实践Signed HTTP Exchange 「SXG」它也是 AMP conf 2019 的亮点，其效果为：访问了 Webnovel Google 域名下的 AMP 页面，浏览器 url 地址展示的是 Webnovel 主站的域名（如图3-1）！这是 AMP 今年主推的功能之一，有些公司已进行实践，例如 Yahoo Japan，而 Webnovel 也抓住了时机、成功地进行了实践，其效果及实现细节可以参考「 Webnovel 的 SXG 实践 by 刘鹏」。 「图 3-1：Webnovel SXG 实施效果」 amp-story算是 AMP 相当主推的功能了！使用其提供的多样性模板可以更加丰富地全屏展示 Webnovel 的各种故事「 关于 AMP Story，你需要知道这些 by 芯芯」，视频和 animation 的结合使 Webnovel 的用户可以更沉浸的浏览书籍。amp-story 还提供本地化、兼容桌面与移动端的展示等功能，此次 AMP 会议还带来了 amp-story 的一些新推进，例如 amp-story 自动生成工具、 Google Search 结果页直接收录并展示 AMP Story 等多方面的支持，可以说是非常牛了。 AMP conf 2019目前 AMP 还有很多值得实践的功能，这次 Google 团队在东京举办的 AMP Conf 2019 也带来了很多新的想法，不少来自世界各地的开发、产品、设计都簇拥于此，可见 AMP 已逐渐具备广阔的市场。我们也很幸运地被邀请参加这次会议，一起见证了AMP 的新技术及主推的功能、同时也从世界各个公司的 AMP 案例中，再次深刻地体会到了 AMP 技术的价值、潜力。 「AMP conf 2019 in Tokyo」 总结一切新技术的应用都应该服务于用户，而衡量一个技术是否值得实施的途径之一就是看数据。Webnovel 在实践 AMP 后，最显著的改变非常符合 AMP 的核心目标 - 页面加载体验的极致提升（87% 的提升），除此之外，GA 的数据也证实了一些其他的优势，例如，Webnovel 主要页面的 PV 在应用 AMP 技术后有所提升（阅读页 PV 增加近 59%）、Webnovel Google 搜索引擎的来源提升了 18%，从数据上来看 Webnovel 的 AMP 实践是非常有意义的。]]></content>
      <categories>
        <category>AMP</category>
      </categories>
      <tags>
        <tag>Webnovel</tag>
        <tag>AMP</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google AMP WebPackage 在 Webnovel 的应用]]></title>
    <url>%2F2019%2F04%2F19%2F20190419%2F</url>
    <content type="text"><![CDATA[之前我们的文章（文章链接）也有介绍过，Webnovel （起点海外）在去年年初就将首页以及全部阅读页都接入了 Google 的 AMP 技术，并且从体验和数据上来说都取得了不错的效果。在去年年底我们又进行了一次迭代，把更多的阅读页内容也加入到了 AMP 当中。用户可以在 Google Search 当中搜索到我们的小说内容，并且很快就可以进行阅读。但是同时我们也发现了一些问题，用户在搜索结果的第一个落地页显示的内容是我们的，但是 URL 却是 Google 的 URL。虽然 Google 在顶部加了一个 m.webnovel.com 来源的标识，但是很多用户依然会误解，并且给我们的统一品牌宣传带来了影响。 显然 Google AMP 团队也注意到了这一点，在去年年底的时候推出了 AMP WebPackage 技术来解决这个问题。 WebPackage 背景讲到 Package，大家可能想到的都是 Webpack，Rollup，Parcel 这些打包工具。而我们这次讲的是 Web Package。Web Package 解决了什么问题呢？它可以让你把你的文件打包给第三方，但是浏览器访问的时候却可以识别出来你真实的域名。我想很多同学第一反应就是想到 CDN，因为现在 CDN 都是托管在第三方的云厂商，为了在云厂商配置我们自己的域名，我们必须把自己的证书私钥配置在云厂商的后台管理页面上，这样可以实现用户访问的是云厂商的 CDN 服务器但是显示的却是我们自己的域名。这种操作带来两个问题，一个是存在着被第三方云厂商泄漏我们证书私钥的风险，另一个是证书过期的时候要记得去第三方平台更新。而 Web Package 就是用来解决这些问题的。 Web Package 的这个特性也正好可以用来解决我们上面发现的问题。 之前的 Google AMP 技术可以让用户在 Google Search 搜索结果页面当中非常迅速地进入到搜索结果页面。为了保证加载速度尽可能地快，Google Search 其实是将符合 AMP 标准的页面缓存进 Google 的 CDN 当中，当命中搜索结果的时候，再从 Google CDN 中加载进来，从而保证了非常快的加载速度。这其实跟我们平常使用 CDN 加速是一样的。必然会带来一个问题，就是展示出来的页面 URL 是 Google 的地址，而非我们自己的域名地址。就如图 1 所示。 为了解决上面的问题，让用户有更好的体验，Google AMP 团队在去年将 Web Package 引入到了 AMP 技术当中。我们也有幸成为了首批接入这个技术的国内发布商。在昨天刚刚结束的 Google AMP 2019 会议上，也得到了 Google 官方的认可。 实现 Web Package 中的 Signed-HTTP-Exchanges在接入 AMP Web Package 过程中，最重要的一步是将我们的内容返回给 Google 爬虫，而这些内容是需要使用我们的证书进行加密的，这个技术称为 Signed-HTTP-Exchanges (缩写为 SXG)。下面我们将详细介绍如何实现 SXG 并最终在从 Google Search 结果无缝浏览我们的站点。 整个操作不算复杂，一共分为以下三步： 1. 从你的 CA 厂商那获取一个支持 SXG 的证书这是最重要的一步。如上所述，返回给 Google 爬虫的内容需要使用证书进行非对称加密。而这个证书是必须拥有一个 SXG 的扩展。截止此文章发布日期，只有 Digicert 证书颁发商是支持颁布此类型证书的。并且此证书必须使用 EC 密钥（非 RSA 密钥）以及 prime256v1 算法生成。 需要注意的是，这个证书仅用来给返回谷歌爬虫的 AMP 文档进行加密。之前接入层是什么证书依旧使用什么证书，是没有影响的（需要注意生成新证书不能导致现在在用的旧证书被颁发商吊销）。 2. 在服务器上按照 amppackage 官方步骤部署 amppkg部署 amppkg 没有什么值得说明的，唯一需要注意的是 amppkg 的配置文件。要捕获请求参数的时候需要加上 QueryRE = “.*”，其他也没有要特别注意的。 amppkg.toml ---------- Port = &apos;port listening&apos; CertFile = &apos;path/to/fullchain.pem&apos; # SXG cert from your CA KeyFile = &apos;path/to/privkey.pem&apos; # SXG cert key OCSPCache = &apos;/tmp/amppkg-ocsp&apos; [[URLSet]] [URLSet.Sign] Domain = &quot;amppackageexample.com&quot; QueryRE = &quot;.*&quot; # to capture query string 3. 配置 AMP SXG 回源下面是简单的 AMP SXG 回源的架构图。 然后就是配置回源接入层了，为了更详细描述这个问题，我们画一个 Webnovel AMP 的回源流程图。 现在 Google 爬虫抓取 SXG 加密的 AMP 文档会有两次请求操作。第一次是一个正常的爬取操作，如果后台是支持给 SXG 加密的 AMP 内容文件的，则可以在返回的 header 头上加上 Vary: AMP-Cache-Transform,Accept，Google 爬虫识别到这个 header 头之后就可以进行第二次爬取操作，并且会在 header 头上带上 AMP-Cache-Transform: google 用来跟第一次爬取操作进行区分。我们的接入层反向代理在识别到这个头部之后，将请求转发到对应的 amppkg server，amppkg server 将对应的内容返回给爬虫即可。 虽然我们给 amppkg server 配置了一个证书，但是这个证书仅用来对内容进行加密，连接是不加密的。所以我们的反向代理转发到 amppkg server 依然用 http 而非 https。 upstream amppkg { proxy_pass http://IP:PORT; } upstream webnovelBackend { proxy_pass http://IP:PORT; } location ^~ /amp/ { if ($http_amp_cache_transform = &quot;google&quot;) { rewrite ^/(.*)$ /ampSXG/$1 last; break; } # allow google to fetch SXG (Signed Exchange AMP HTML) add_header Vary &quot;AMP-Cache-Transform, Accept&quot;; proxy_pass http://webnovelBackend; } location ^~ /ampSXG/ { # some detail omitted proxy_pass http://amppkg/priv/doc/https://m.webnovel.com/; } # this location is for browser to get cert for verifying SXG document location ^~ /amppkg/ { proxy_pass http://amppkg/amppkg/; } 到了这里就完成了整个后台的配置，可以用官方提供的方法来进行验证。要想正式环境（Chrome 73 以及以上才支持 SXG 功能）验证就需要等待一段时间，让 Google 爬虫来爬取这些 SXG 加密的 AMP 文档内容了。 结果展示下面是 Webnovel 在实现 SXG 之后的一个演示视频。 接入了 AMP Packager 之后的 AMP 和之前有什么区别呢？虽然我们的数据还不够多，但是我们分析结果看来，最终跳出率，以及每 session 浏览的页面数对比之前都得到了比较好的优化。待 Chrome 73+版本得到更多普及之后数据会更加明显，后续再跟大家进行分享。 Tips: 有一个小技巧，正常情况下从 Google Search 引流过来的用户只能享受第一个落地页面的 Google Cache 加速。后续就是我们自己网站的内容了，需要我们自己进行接入优化。但是很多时候在全球化的接入能力上，我们相对 Google 来说还是偏弱的。有没有什么办法让用户尽可能地都浏览 Google Cache 缓存里面的页面呢？在用户需要进行一些进一步操作的时候，我们再切到我们自己的页面。我们研究了一下发现还是可行的。我们的 AMP 页面对应 Google Cache 中的地址是有一个映射关系，比如说我们的 Webnovel AMP SXG 首页对应 Google Cache 缓存的地址就是 https://m-webnovel-com.ampproject.org/wp/s/m.webnovel.com/amp/ ，我们在页面当中跳转的 AMP SXG 页面都换成对应的 Google Cache 地址就满足了我们的需求，即有效利用了 Google Cache 又让用户像在我们自己站点上操作一样。视频如下： 引用文章： https://medium.com/@lewpengfeifei/ways-to-implement-signed-http-exchanges-with-google-amp-5ad1ce92e1e https://github.com/ampproject/amppackager https://www.digicert.com/account/ietf/http-signed-exchange.php https://github.com/WICG/webpackage/tree/master/go/signedexchange]]></content>
      <categories>
        <category>AMP</category>
      </categories>
      <tags>
        <tag>Webnovel</tag>
        <tag>AMP</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向体验的重构优化]]></title>
    <url>%2F2018%2F09%2F10%2F20180910%2F</url>
    <content type="text"><![CDATA[前端重构程序员是一个关注代码同时还要留意体验的异类。代码的优化虽然难，但是有比较多的性能测试工具去证明优化的成果。然而体验这种东西，我们又要如何去证明它的好与坏呢？ 一、视觉体验优化 页面加载 数据请求 图片渲染 二、数据证明体验效果 今天我着重会基于「webnovel」PC站点从以上两点给大家介绍，如何从体验的角度去做重构的优化，并如何用数据去证明你的优化是有效果的。 一、视觉体验优化我们要做体验的优化，首先要我们要知道什么才是好的体验。 不知道哪里听过这么一句话，「 好的体验，就是感觉不到在体验 」。这句话听起来很矛盾，但是却和业界公认的体验小红书「 Don’t make me think 」的理念一样。你想用户来「 webnovel 」是来看小说的，不是来称赞我们网页体验做得多么优秀的。当用户开始关注到我们网站体验的时候，那正是说明我们的体验不好的时候。 那用户在什么地方容易感受到我们网站的体验呢？ 页面加载 第一个地方就是页面加载的时候。这里我们明显可以看到「 webnovel 」的 Logo 和三个小图标在页面刷新的时候，会有一瞬间从无到有的过程。 我们「 webnovel 」站点是面向全球海外用户的，跳出了国内兼容 IE 浏览器的怪圈，于是在小图标这块我们选择了浏览器兼容性要求高，但是呈现效果却更好的SVG图标「 SVG 属于矢量图标，在能保证体积更小的情况下，还能在放大缩小的时候不失真 」。我们将 Iconfont 「来自阿里的在线图标管理工具 」自动帮我们生成的 JS 代码引用到页面中，结果就出现了上面的呈现效果。 这个原理其实很简单，我们 SVG 图标的 DOM 结构是在 JS 执行之后动态添加到我们的标签内部的。所以就会出现先呈现页面，再呈现图标的效果。于是我们很自然的想到，直接将 JS 生成的 DOM 结构放到我们的内部，来解决这个问题。 但是很傻很天真，在拷贝 DOM 结构的时候我们发现，这个 SVG 代码量也太多了，直接放到页面内部会大大增加我们 HTML 的代码量，影响整个页面呈现的速度，这个感觉是捡了芝麻丢西瓜。 最后我们采用的解决方案是，把 SVG 图标做了拆分，首屏的显示的图标我们采用直接添加 DOM 的方式，其它剩余的图标还是选择 JS 动态加载老方法。这样首屏之外的图标即使有闪动用户也很难看到。于是我们解决了首屏图标闪动的问题，也避免了 SVG 图标代码量的问题。用户感知不到图标的闪动，也就不会花时间去思考我们页面加载是快是慢的体验问题了。 提前加载首屏数据，能一定程度上增强我们用户刷新和跳转页面时候的体验。 数据请求 第二个地方的就是我们数据请求的时候。当我们切换TAB的时候，能明显看到一个 Loading 的效果。用户的动作触发数据请求，在等待的过程我们用 Loading 来告知用户这一状态，以减弱用户等待的焦虑。这其实是一个对于数据加载，增强体验常规的做法。 可是不管我们的数据请求多么的快，用户都还是能明显能看到这个 Loading 的效果。这并不是我们想要的。 我们这边处理的办法是，在用户鼠标放到这个按钮的时候，我们认为用户是有了点击的意愿，于是我们就提前发起了数据请求的操作。当用户按下这个按钮的时候，我们的数据请求的整个过程可能已经结束，而这也就意味着我们的 Loading 状态已经消失。此时用户就能直接看到我们加载好的数据了。也就是说很有可能，在整个过程中用户是看到不到我们的 Loading 状态的。这不就是我们想要的体验上的优化吗？ 利用用户操作的空闲时间，提前做一些预处理，不失为一个增强数据请求体验的好办法。 图片渲染 我们都知道，图片和图标都是属于展示性的元素，特别是像我们 「 webnovel 」网站设计师很用心制作的书封，我们自然会愿意选择体积更大但是质量更高的高清图。为了避免影响正文的展示，我们又不得不选择了类似图片 Lazyload 的机制，让这个图片延迟加载。 但是可以明显看到这和之前的数据加载的 Loading 逻辑一样，需要一个表示 Loading 态的占位图。等图片加载完成，占位图会一瞬间被我们的高清书封替换，于是此时就出现了我们不期望的闪动。 当用户一看到闪动，他们就会去思考你这个加载是快还是慢。但是我们要的是 「Don’t make me think 」。我们不希望让用户去思考除开我们产品之外的东西。所以我们得想个办法弱化甚至去除这种闪动。 讲到这里呢就不得不科普以下我们浏览器本身就有的图片缓存机制了。在一定时间段内你浏览器访问过的图片，会被浏览器缓存。当你再一次看到这个图片的时候，这个图片就直接读取浏览器缓存的内容一瞬就打开，不会有闪动问题。 于是我们就想是不是可以利用这个机制，解决之前闪动的问题。但是现在难点是，我们详情页的书封是比首页的书封大的。因为尺寸不一样所以是不同的图片，于是就没有缓存这个概念。 如果我们让详情页也用首页的书封，详情页小图被拉伸就会看起来很模糊。如果首页用详情页的大书封，首页的图片数据加载开销又太大。 我们这边采用的解决方案是，三层叠加法。我们把占位图，小书封，大书封，按照上图的层级完美的叠在了同一个位置。当用户从首页进入到我们详情页的时候，我们占位图和小书封都是直接使用浏览器缓存瞬间呈现的，因为小书封是叠在占位图之上的，所以用户是看不到占位图的。而此时大书封正在加载，当大书封加载好了之后，就会盖在小书封之上。等用户仔细看这个书封的时候，这个大书封其实很有可能已经加载完成。 从上图的GIF可以看出，整个过程就从之前的占位图到大书封的闪现，变成了现在的小书封到大书封的渐变。其实这是很难被用户发现的。 看到这里可能有同学会问说，既然这里都看不到占位图，为什么还需要加载这个图呢？其实原因很简单，因为不是每个人都是从首页进入到详情页的。有可能用户是直接打开的这个链接。那么此时占位图就回到了最初的逻辑。先看到占位图然后再看到书封。当然我也得承认对于这样的用户，我们其实是多加载了一个小书封的资源的。但是对于体验上的优化来说，这一点资源的消耗我个人认为还是可以接受的。 还有一个好玩儿的点是，在这个地方因为同时加载了，占位图，小书封，大书封，它们作为图片也都会被浏览器缓存，当用户跳转到其它页面的时候，如果有相同的图片，那又是瞬开的。这样我们就充分的利用了浏览器缓存，让用户在我们网站上的体验得到了进一步的提升。 图片缓存，让网站体验比好更好。 二、数据证明体验效果视觉层的体验优化是所见即所得的，你可以很快的看到优化的成果。但是有很多因为浏览器差异，或者用户差异引起的体验问题，我们没法直观和快速的去证明体验优化的效果。我们就得靠数据去证明了。 要用数据说话，首先我们得有数据，而这个数据的收集工具我们海外 PC 站用的则交给了来自 Google 的 Analytics。这边给大家讲关于这个的一个有趣故事。 有一天我在用 webpagetest 「 一个全球知名的测试网站加载速度的工具 」测试我们 「 webnovel 」页面的时候我看到了这样一个结果。 大家注意看那个最长的绿色，看到了吧，一个 DNS 加载怎么比后面的 SSL + CSS 加载 + CSS渲染还要长？CSS 可是强制阻塞我们页面渲染的重要元素，它要是慢了，你网站做再多优化都没有用。这个你让人怎么忍？ 怎么办呢？我们选择了一个暴力但是有效的办法，直接把 CSS 合并到我们的 HTML 文件中 「 CSS 内联到 HTML 内部 」。CSS 文件都没有了，看你还怎么 DNS、SSL … 哇！好棒，我拿着这个去找老大邀功。老大啪啪给我提了两个点就把我打懵了。 第一， 你这个明显是首次加载页面时候的效果，对于大多数这个 CSS 文件已经有缓存的用户，你如何证明，这个优化对他们是又用的？ 第二，「 webnovel 」是面向全球的网站，你又如何证明，这个优化对所有地区的用户的优化力度 ？ 是啊我要怎么证明？「 webnovel 」全球这么多的用户，我就用一份 「 webpagetest 」 的测试报告去涵盖所有的终端和用户群体，显示是不具有公信力的。并且我又要如何证明这个优化的力度是多少？ 此时中国好同事出现了，我的前端逻辑小伙伴帮我在框架机内部做了一个随机预处理的AB样本输出。道理很简单，就是让 50% 的用户是用原始的方式加载我们的 CSS ，另外 50% 的用户使用我们 CSS 内联到 HTML 内部的方式。这样我只需要加个标识符区别一下这两个样本，上报到 GA 「 Google Analytics 」 ，然后 GA 会自动帮我们统计和处理这些样本，最后我只需要将这两个样本的平均值做一个 10 以内的减法，就知道了我们的优化力度具体是多少了。 然而另一个问题出现了，我们应该把什么作为数据上报给 GA 呢？显然用整个网页的加载时间去证明 CSS 的加载是不对的。那我用 CSS 加载完成之后的那个时间去证明？可是我又怎么能证明 CSS 加载完成之后页面就已经渲染好了呢？我们不是在做体验的优化吗？又怎么能仅凭借 CSS 文件的加载来证明用户体验变好了呢？ 此时我是凌乱的。不行，整个场面我要HOLD住，不能慌。 体验，体验，CSS都没有加载，用户连页面都没有看到又怎么能叫体验？于是用户刚看到页面的时间，被我认定是一定程度上可以证明体验优劣的。 怎么去获取这个时间呢？其实利用 performance API，就可以获取到上图所示的浏览器各个阶段的时间。 Chrome浏览器 可以用 window.chrome.loadTimes().firstPaintTime；IE8+ 浏览器可以用 window.performance.timing.msFirstPaint； 来获取页面开始渲染的时间。最后大家一致的意见是，将这个 「 firstPaintTime - navigationStart 」的时间近似理解为用户从访问页面到看到页面的时间。 于是，我很开心的把这个这个时间上报到 GA，然后版本上线，等待数据收集。最后得出如下的统计结果： 看到以上的数据结果，这个优化的时间和总时间比起来比预想的差太多了。感觉不应该啊？ 当我们仔细分析这个数据，发现在这整个的时间段内，服务端的时间占了 1.1s 。我在这拼命的优化体验，可是最后发现体验的瓶颈并不在我们前端这边。这充分的说明，有的东西还是得靠数据说话，而不是你以为你以为的就是你以为的。当然除开这个瓶颈时间我们可以得出如下的结论。 至此我们有理有据的证明了优化体验的成果，虽然结果出乎了我们的预料，但是却证明，数据上报是能够证明我们体验成果的一个有理证据。 当然我们也把这个瓶颈问题，反馈给力服务端的同学。然后得到的答复是，「 webnovel 」还属于我们海外站的新项目，很多海外服务器有待跟进。相信在后续设备之后，会解决这个痛点。 数据上报，让你的体验优化有理有据。 总结篇幅有限，这边我只是零散的列举了，我个人认为可以从用户体验角度去做的几点重构优化，以及如何利用数据去证明你优化的力度。希望对于大家有一定的启发和帮助，有什么问题，也请给我留言，我们可以深入的交流。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>用户体验</tag>
        <tag>性能优化</tag>
        <tag>Webnovel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 在元气阅读的实践]]></title>
    <url>%2F2018%2F08%2F01%2F20180801%2F</url>
    <content type="text"><![CDATA[前言经历了三个多月的集中开发，阅文集团旗下二次元产品「元气阅读」APP 终于在各大应用商店上架了。「元气阅读」APP 大部分的功能模块基于 React Native 开发，整个开发过程前端团队趟了不少 React Native 的坑，同时也积累了不少实践心得，与大家一起分享。 一、业务背景与技术选型在使用 React Native （以下简称RN）之前，和业界大部分团队一样， 我们 APP 的开发模式采用的是客户端（iOS/Android）内嵌 H5 的 Hybrid 开发模式。一开始，我们除了采用比较成熟的离线包方案管理静态资源，在首屏加载体验上我们也做了不少优化工作，但发现 H5 线上的体验和性能数据与原生还是有不少差距，所以我们决定引入新方案。 RN 和 Weex 已经是业界两个相对成熟的 Hybrid 解决方案，基本能满足我们的需求： 用户体验：相比于 H5 页面，RN 和 Weex 在用户体验上有了很大的提升，体验几乎接近原生 人力成本：相比于客户端，RN 和 Weex 的一套代码可以跑在 iOS、Android 两端，且代码重用率也较高 灵活发布：RN 和 Weex 都拥有热更新能力 最终我们选择了 RN 作为解决方案，主要是考虑了几个因素： 社区现状：相对 Weex，RN 的社区活跃度和 Facebook React 周边生态更好 大厂背书：腾讯、京东、百度和携程都有大型产品在线上跑 团队现状：早在 17 年上半年，阅文前端团队已经选型 React 作为我们前台产品线的主要研发技术栈，且大部分成员都能驾驭 React 二、应用场景在「元气阅读」APP 中，使用 RN 开发的应用场景达到了 70% 左右。用户能看到的页面中，除了书架、注册登录和阅读引擎，其它模块几乎都是使用 RN 完成开发，「元气阅读」APP 已经属于国内大型产品中，超大规模的 RN 应用了。欢迎大家在各应用商店（iOS、Android）搜索「元气阅读」下载体验。 三、导航管理对于 RN 的开发，导航的前期规划十分重要，通常在搭建项目时就需要提前考虑。关于导航组件的选择，react-navigation 是个不错的选择，我们希望 react-navigation 能在业务场景更加通用。 1、统一跳转规则Native 与 RN 互跳是最常见的需求。有了统一的 URL，只需维护一份 sitemap 和实现一个 open 接口，就可以很容易的在 Native 与 RN 中互相跳转。 react-navigation 是使用 routeName + params 的形式跳转的，所以需要在调用 router.getStateForAction 之前做一点调整： 1234567891011// 修正 action: 允许 navigate/push/reset 动作传 urlif (isPushLikeAction(action) || isReplaceAction(action)) &#123; if (isRouteUrl(action.routeName)) &#123; // 使用 path-to-regexp 库来判断 url 对应的 routeName + params const route = parseRouteByUrl(action.routeName) if (route) &#123; action.routeName = route.name action.params = route.params &#125; &#125;&#125; 2、实现 404 跳转在 Web 开发中，404 页面是一个很常见的逻辑，参照上面的方式， RN 可以这样实现： 123456789// 修正 action: 当 navigate/push/replace 跳转到未知 routeName 时，调整为定义的 notFoundRouteNameif (isPushLikeAction(action) || isReplaceAction(action)) &#123; // 修正 action: 提供 404 能力 if (allRouteNames.indexOf(action.routeName) === -1) &#123; const oldAction = &#123; ...action &#125; action.routeName = notFoundRouteName action.params = &#123; action: oldAction &#125; &#125;&#125; 3、控制页面生命周期在项目开发过程中，经常碰到这样的需求，回到原来页面之后要刷新原页面的数据，比如登录之后、进入详情页完成某操作之后回到列表页等。 「元气阅读」项目刚启动时 react-navigation 还是 0.x 版本，只能用 onNavigationStateChange + context 才能让页面感知 focus/blur 。1.x 版本之后，我们可以通过自带的 addListener 方法来监听 didFocus 或 didBlur 事件。 4、优化页面二次打开「元气阅读」是一个以 RN 为入口的应用，在正常的使用过程中，需要频繁的从 RN 切换到 Native 或从 Native 切换到 RN，这样就会有多个 RN 页面（根组件），而第二个根组件在初始化的时候就需要定位到指定页面，所以和 Native 约定，通过 initialRouteUrl 或 initialRouteName + initialRouteParams 来告诉 RN 需要定位到什么页面： 12345678910111213141516171819202122232425262728293031323334const navigator = getActiveNavigator() // 需要全局维护一个 Navigator 的堆栈let nextState = originGetStateForAction(action, state) // 调用原始的 getStateForAction 获取新的/初始化的状态if (navigator) &#123; const &#123; initialRouteName, initialRouteParams, goBackOnTop &#125; = navigator.props // 读取 navigator 的 props if (isInitAction(action)) &#123; // 支持通过 initialRouteName &amp; initialRouteParams 初始化到相应页面 if (initialRouteName) &#123; const initialActionPayload = &#123; routeName: initialRouteName, params: initialRouteParams &#125; const initialAction = NavigationActions.navigate(initialActionPayload) nextState = router.getStateForAction(initialAction, nextState) if (!isTopNavigator() &amp;&amp; nextState.index &gt; 0) &#123; // 非第一层 RN 实例且有两个页面的时候(前面 navigate 到了非一级页面)，保留最后一个页面 nextState = &#123; ...nextState, index: 0, routes: nextState.routes.slice(-1), &#125; &#125; &#125; &#125; else if (isBackAction(action)) &#123; // 在第一层页面，并且不是是第一个 Navigator，则调用 goBackOnTop 关闭 RN if (isTopScren(state) &amp;&amp; !isTopNavigator( ) &amp;&amp; typeof goBackOnTop === 'function') &#123; goBackOnTop() if (nextState === state) &#123; // 防止 Android 的物理返回键导致退出 App nextState = &#123; ...nextState &#125; &#125; &#125; &#125;&#125;return nextState 5、状态本地存储组件 react-navigation 在 2.x 版本新增了状态本地存储功能，在 reload 之后可以直接定位到之前的页面，但是需要注意两个点： 在「元气阅读」这种多个根组件的业务场景，每一个根组件的 rootNavigator 需要有个标记区分，建议以索引区分 在页面出错（红屏）之后，为了避免 reload 还是停在当前错误页，可以在 componentDidCatch 里面清除本地存储 四、状态管理与数据持久化在「元气阅读」里，我们经常需要缓存用户的信息、浏览过的书详情信息以及用户收到的消息等等，这样用户在离线访问「元气阅读」时就能避免白屏或异常的情况，而且还可以实现“秒开”。 举个例子，当用户第一次打开书籍详情页的时候，把书书籍详情的信息缓存下来；第二次再打开的时候，就可以达到秒开的效果。秒开效果可以看下图： ▲跳转详情页 我们选择 redux 和 redux-persist 搭配一起使用，来实现数据共享以及数据持久化缓存。 1、redux选择用 redux 主要是实现数据共享的功能。通过 redux 单项数据流的特点，每一步操作都有迹可循，比较容易排查问题。 在写 redux 的时候，可能大家觉得会需要写很多样板代码。在这里推荐一下 redux-actions 这个库，能够帮助我们减少一些代码量。下面简单的举一下例子： 12345678910111213141516171819202122232425// 常见的写法export default (state = &#123;&#125;, action) =&gt; &#123; switch (action.type) &#123; case INCREASE: return &#123;...state, total: state.total + 1&#125; case DECREASE: return &#123;...state, total: state.total - 1&#125; default: return state &#125;&#125;// 通过 handleActions 方法import &#123; handleActions &#125; from 'redux-actions'export default handleActions(&#123; [INCREASE]: state =&gt; &#123; ...state, total: state.total + 1 &#125;, [DECREASE]: state =&gt; &#123; ...state, total: state.total - 1 &#125;&#125;, initialState = &#123;&#125;) 2、redux-persistredux-persist 会订阅 store，一旦 store 发生变化，就会触发存储操作。这样当我们操作 store 的时候，数据也就会更新到本地了。 在开发项目的时候可能会发现，我们在 store 中共享的数据有一些可能是不需要被缓存到本地的。比如说搜索结果页，因为每次搜索的关键字不一样，结果也是不一样的，这样的数据被缓存到本地就没有意义。那我们怎么来控制一些数据不被缓存到本地呢？ redux-persist 支持配置黑白名单，意思是只持久化白名单中的数据或者不持久化黑名单中的数据。这样就可以根据需求来配置黑白名单，从而决定哪些数据需要被缓存到本地，哪些数据不需要被缓存。例如： 1234567891011121314import &#123; createStore, applyMiddleware, combineReducers &#125; from 'redux'import &#123; persistReducer &#125; from 'redux-persist'import thunkMiddleware from 'redux-thunk'import storage from 'redux-persist/lib/storage'const rootPersistConfig = &#123; storage, key: '***', blacklist: ['***'] // 黑名单&#125;const enhancer = applyMiddleware(thunkMiddleware)export const store = createStore(persistReducer(rootPersistConfig, rootReducer), enhancer)export const persistor = persistStore(store) 五、性能优化 A compelling reason for using React Native instead of WebView-based tools is to achieve 60 frames per second and a native look and feel to your apps. Where possible, we would like for React Native to do the right thing and help you to focus on your app instead of performance optimization, but there are areas where we’re not quite there yet, and others where React Native (similar to writing native code directly) cannot possibly determine the best way to optimize for you and so manual intervention will be necessary. We try our best to deliver buttery-smooth UI performance by default, but sometimes that just isn’t possible. 在 RN 文档里看到一段关于性能的解读，里面提到：「目前在某些场合 RN 还不能够替你决定如何进行优化（用原生代码写也无法避免），因此人工的干预依然是必要的」，我们确实在性能优化上花费了不少精力。 1、首屏优化运行过 RN 项目的同学不难发现，我们第一次进入 RN 页面时会有一个短暂的白屏，快至几十毫秒，慢至 1 到 2 秒，白屏时间取决于终端的性能，在低端安卓机子表现最差，而且退出后再进入，仍然会有这个白屏。我们实施了几个优化策略： 1）预加载 Bundle在客户端启动时，就开始对 RN 的 bundle 进行预先加载，我们发现这样操作后，白屏操作的时间缩短了不少，特别是安卓设备。但这还不是最完美的，我们仍然会看到很短暂的白屏。 2）优化闪屏逻辑由于大部分 APP 一定是先有闪屏，然后才进入首页。我们完全可以利用这个业务场景，让 RN 程序躲在闪屏下加载，直到加载完毕，通过 Bridge 通知客户端把闪屏关闭，这样就比较巧妙地解决了白屏的问题。 2、交互优先当 JavaScript 线程中同时做很多事情时，很容易就会导致线程掉帧，表现为页面卡顿、动画切换缓慢，我们可以使用“交互优先”的原则去做优化。 1）优先执行用户可感知的操作：如页面场景切换例如，页面转场这个场景。我们就可以把页面逻辑放在 InteractionManager.runAfterInteractions 的回调中执行，这样可以优先保证转场动画的执行，然后才是我们的页面逻辑，很好的规避了转场卡顿的问题。 2）初始化页面尽量渲染少量组件当我们呈现一个页面给用户时，一定是要在最短时间内让用户感觉到页面已经展现完毕了，所以我们在初次展示页面时，可以优先显示固定的占位信息，配合 loading 或骨架图布局不确定的部分，与此同时我们才在背后默默的发起请求（碰到复杂页面，则可拆分多个异步请求），总之整个过程是先保证页面可见，再逐步完整。 3、长列表优化▲组件的子树 这是一个组件的子树。对其中每个组件来说，SCU 表明了 shouldComponentUpdate 的返回内容，vDOMEq 表明了待渲染的 React 元素与原始元素是否相等，最后，圆圈的颜色表明这个组件是否需要重新渲染。 在 React 中如果只是一次这样的组件子树渲染，并不会有太大的性能问题。但如果对于分页长列表这种需要成百上千次的渲染场景，会花费很大的开销在 vDOM 的生成和 Diff 上，而这也直接导致了长列表在 RN 中严重的性能问题。那我们需要做些什么加以改进呢？先来看看这张组件更新渲染的流程图： ▲组件更新流程 当一个组件的 state 或者 props 改变时，就进入了生命周期函数 shouldComponentUpdate，而当 shouldComponentUpdate 返回的是 true ,就会调用 render 方法生成 Virtual Dom，随后和旧的 Virtual Dom 进行比对，最终决定是否更新。所以从中我们明显地看出 SCU 和 Virtual Dom 的 Diff 是影响 Dom 更新的关键所在，为此我们分别针对这两点做了优化： 1）控制好 shouldComponentUpdate 的更新逻辑从上图也可以看出如果 shouldComponentUpdate 返回的是 false，那程序就可以直接跳过生成 Virtual Dom 以及之后的 Diff，这对于一个大列表的场景是相当可观的优化，例如目前我们有一个 1000 条数据的列表，在下拉加载 20 条新数据时，如果没有利用 shouldComponentUpdate 进行控制，会把之前的 1000 条数据也 render 一遍，而在 shouldComponentUpdate 中控制好更新逻辑，就只需要 render 最新的那20条，是不是很大的提升！不过使用 shouldComponentUpdate 要格外小心，你一定要考虑到所有影响更新的逻辑。不然会出现真正需要更新的时候却也没能更新。 来看一个具体的例子，场景是 APP 中的分类列表页，我们在每一个列表项的 render 中打印 log，统计进入 render 的次数。首先来看看 shouldComponentUpdate 不做任何处理的情况，也就是 shouldComponentUpdate 始终返回的是 true： 123shouldComponentUpdate (nextProps, nextState) &#123; return true&#125; 再看看我们在 shouldComponentUpdate 中以图片的 uri 地址过滤掉不必要的渲染项之后的情况： 1234567shouldComponentUpdate (nextProps, nextState) &#123; if (nextProps.imgSrc.uri === this.props.imgSrc.uri) &#123; return false &#125; else &#123; return true &#125;&#125; 从图中左边的控制台很明显的看出，过滤后不论加载到哪一页，都只是渲染最新的20条，减少了大量不必要的渲染。再比较一下在相同条件下两者加载一千条数据的时间： 结果也是显而易见，而且在操作过程中发现未使用 shouldComponentUpdate 的情况下，越往后会越慢，到 1000 条数据时，再加载新数据所要等待的时间简直无法忍受。 2）在数组遍历时，增加唯一标识的 key 值如果更新是不可避免的，那只能想办法去提高 Virtual Dom 的 Diff 效率。我们可以在遍历数组时给每一项加上唯一的 key 值，这样在 Diff 阶段，可以准确知道要操作的子组件，提高 Diff 的效率。 4、动画优化合理运用动画对于 APP 的体验提升有很大帮助。但我们在应用动画时发现在有些场景会出现卡顿、掉帧的现象，本质原因是由于 JavaScript 是单线程的，如果线程中在跑一些比较重的任务，就可能会对动画的性能出现影响。下面介绍几种办法，把动画这件事尽量交于原生： 1）使用 LayoutAnimation针对一次性动画，建议使用 LayoutAnimation，它利用了原生的 Core Animation，使动画不会被 JS 线程和主线程的掉帧所影响。 2）使用 setNativePropssetNativeProps 方法可以使我们直接修改基于原生视图组件的属性，而不需要使用 setState 来重新渲染整个组件树。避免了渲染组件结构和同步太多视图变化所带来的大量开销。 3）使用原生驱动的方式在 Animated 动画设定中，添加 useNativeDriver 字段，并设为 true，这样就可以把动画的执行交由原生处理。 六、发布更新如今由于互联网高速传播的特效，事物发展的速度越来越快，产品快速迭代、试错的能力就显得尤为关键，作为开发者，对我们的挑战就是如何让开发完成的功能快速上线，下面来看看我们是怎么做的： 1、发布我们选择 Jenkins 作为自动化部署方案。通过配置在 Jenkins 中打包脚本来实现自动打包，把 RN 的 bundle 包打到指定的位置，这样就不用每次打包之前再手动打包了，大大提高了效率。 2、热更新由于 Native 端发布一次新版本的成本比较大，RN 的热更新能力就成为了很大的亮点。只需要把最新的 bundle 包发布到服务器，就能够让用户手中的 app 自动下载远端的 bundle 包，然后无感知的更新，可谓是特别的方便。 我们经过调研，最终选择了微软的 CodePush。它提供给 RN 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务，而且还开源了 RN 版本。具体接入的教程可以查看官方网站，这里就不一一赘述了。下面主要讲几个需要注意的点： 1）注册 app在 CodePush 上注册 app 的时候，需要区分 iOS 和 Android，例如 appName-ios 和 appName-android，在发布的时候需要在不同的平台分开发布。 2）key 的配置：Staging 和 Production在注册 app 的时候，会返回一套 deployment key，分别为 Production 和 Staging 环境（后续也可以自定义 dployment key 名称），在集成 CodePush SDK 的时候会用到。Production 对应生产环境的 key，Staging 对应测试环境的 key。这样就可以分别更新不同环境的包。如果想要查看 app 的 dployment key 表，可以使用下面的命令： 1code-push deployment ls &lt;appName&gt; -k 3）RN 接入 CodePushRN 端接入 CodePush 非常简单，只需要在根文件中加入几行代码就可以了。CodePush 传参的时候可以根据环境的不同做不同的配置。代码大致为下面这样： 12345678910111213141516171819import React, &#123; Component &#125; from 'react'import codePush from 'react-native-code-push' // 引入 codePush const codePushOptions = __DEV__ ? &#123; updateDialog: true, // 显示更新弹窗 installMode: codePush.InstallMode.IMMEDIATE // 立即更新（会打断用户操作） &#125; : &#123; // 下次 app 从后台切换到前台时检查更新，并下载最新的包 checkFrequency: codePush.CheckFrequency.ON_APP_RESUME, // 下次重启的时候更替换成最新的包 installMode: codePush.InstallMode.ON_NEXT_RESTART &#125; @codePush(codePushOptions) export default class App extends Component &#123; render() &#123; ... &#125; &#125; checkFrequency 和 installMode 是可配置的，具体的配置可以根据需求来决定。 4）版本控制在热更新的时候需要控制版本号，默认是当前安装包的版本（三位数版本号），如果需要指定版本号的话，可以在执行热更新命令的时候加上 -t，后面跟需要更新的版本号就行了。 七、异常监控我们借助了腾讯 Bugly 平台进行线上异常的监控。Bugly 平台能为开发者提供异常上报与运营统计功能： Bugly 会上报运行错误、崩溃和卡顿的异常，并提供相应的数据统计和告警机制，使我们可以尽可能快地感知到线上异常，掌握用户侧整体的运营稳定性和流畅度的情况； Bugly 平台提供日志上报功能，可以协助定位问题； Bugly 平台也可以针对版本，机型，系统，来对比异常数据的变化。 例如，下图是对 Crash 率的统计： Crash 还可以根据系统、设备和 APP 版本等维度来细化分析。 还可以统计最影响用户的 Top 问题： 八、一些坑和小贴士在几个月的开发过程中，我们遇到了不少坑，也发现了一些好用或者没有被注意到的小技巧，下面和大家分享其中的一部分： 1、坑1）Image 组件在 Android 上潜在的内存泄漏 Bug在安卓中，加载一张尺寸远大于容器的图片，内存会突然猛涨，在这张图上下滑动，程序就直接因为内存不足而崩溃了如何解决呢？其实办法也很简单，只需要设置 Image 组件的 resizeMothod 属性为 resize 即可，如下图： 2）使用 InteractionManager.runAfterInteractions 时的注意事项我们知道 InteractionManager.runAfterInteractions 的回调是需要完成动画后才执行，我们的程序中发现过这样一个的 bug，在点击某个按钮后，就怎么也进不到 runAfterInteractions 的回调中。经过排查，原来是我们执行了一个无限循环的动画（loading 效果），并且没有关闭，所以就永远进不到 runAfterInteractions 的回调了。所以大家在开发中碰到循环动画要注意处理。 3）使用 FlatList 列表出现页面跳动问题FlatList 有一个叫 getItemLayout 的优化属性，如果你是个定高的列表项，设置这个属性可以大大提高列表渲染的效率。然后我们遇到的问题是，在高度不确实的时候，也设置了这个属性，导致最终渲染时实际高度和我们预设的值不一致，出现了跳动。所以，如果不确定高度，千万别设置 getItemLayout 属性。 4）短时间内重复点击出现多个相同页面的问题这不单单是 RN 的问题，各端应该都无法避免。所以通常在各种技术栈的导航库中都对此进行了修复，我们刚开始的预期就是 React Navigation 在内部肯定解决了这个问题，但发现实际上并没有。于是我们就对 React Navigation 的跳转做了一次增强，思路是判断下个路由的地址和上个路由一致，那就不予处理： 123456789101112131415161718function isInCurrentState (state, nextState, routeName) &#123; if(nextState &amp;&amp; nextState.routeName === routeName &amp;&amp; !deepDiffer(state.params, nextState.params)) &#123; return true &#125; if(nextState &amp;&amp; nextState.routes) &#123; return isInCurrentState(state.routes[state.index], nextState.routes[nextState.index], routeName) &#125; return false&#125;const nextState = originGetStateForAction(action, state)// 避免重复跳转if (nextState &amp;&amp; action.type === StackActions.PUSH) &#123; if(isInCurrentState(state, nextState, action.routeName)) &#123; return state &#125;&#125; 2、小贴士1） iOS 模拟器中你可能不知道的两个选项 打开虚拟键盘：我们在开发输入相关场景时，iOS模拟器默认未开启键盘，需要在 HardWare-&gt;Keyboard-&gt;Toggle Software Keyboard 进行开关； 慢动画开关：很多同学碰到这个问题，不知道点了哪个按键后，模拟器中的任何操作都得比无比缓慢，各种重启、清缓存都无效。这是由于我们不小心触发了快捷键，打开了慢动画模式，可以在 Debug-&gt;Slow Animations 中关闭(快捷键是 command+T)。 2）原来 RN 和原生的通信也可以是同步的我们知道 RN 和原生的通信是异步的，但如果是一些全局的常量（环境变量、版本信息等），其实可以以同步的方式在启动 RN 时直接挂在 NativeModules 上，这样使用起来就很方便。 3）Image 组件一些值得关注的属性 defaultSource（iOS Only)：正常我们要实现一个默认图功能，需要先给图片设置默认图链接，然后在图片下载成功的回调里再改变状态，替换默认图。这个属性就帮你做好了这些，可惜的是只支持 iOS。 getSize：当我们要获取图片的宽高，然后再处理图片相关逻辑，就可以用这个 API。 prefetch：对图片强制缓存。 queryCache：这个 API 可以获取到图片是否缓存，如果已缓存，则下发是在硬盘还是内存。对于要处理一些缓存逻辑还是很有用的，不过要注意的是虽然官方没有标注 Android Only，我们只在 Android 获取成功过，iOS 并没成功。 4）Text 组件里一些值得关注的属性 allowFontScaling（iOS Only)：这个属性用来控制是否跟随系统字体大小。如果你的APP布局会因为设置字体而失控，可以考虑开启，不过此属性只支持 iOS，安卓需要其它方法解决。 selectable：这个属性可以用来开启文本的复制、粘贴功能。 5）FlatList如何实现一行多列FlatList 提供了一个叫 numColumns 的属性，你只需要设置一行的列数，便可轻松实现一行多列的布局如下图： ▲一行三列的布局 6）调试工具推荐使用 react-native-debugger，它集成了 Chrome 的 DevTools 以及 react-devtools ，还支持 Redux 的相关调试，可以说是很强大了。 7）性能检测可以通过客户端自带的软件进行性能检测。iOS 推荐 Xcode 自带的 Profile；Android 推荐 Android Studio 自带的 Android Profiler。 九、总结虽然 RN 目前还存在着一些不足，但通过「元气阅读」项目实践，结果证明在人力、性能和效率上，RN 是符合我们预期的。对于 RN 在业务场景的最佳应用，我们也总结了几点： 重运营场景：有运营需求的场景，适合用 RN 实现，如书城页、福利页等 快速迭代场景：功能未健全，产品需迭代试错的功能场景，适合用 RN 实现，如元气圈、小说书城、漫画书城等 固定信息展示场景：固定内容的信息展示页面，适合用 RN 实现，如排行榜、本大人、一级分类页等 长列表场景： 由于 RN 列表的渲染机制限制，图+文长列表里有大量未知尺寸的图片，不太建议 RN 实现，如类似元气圈、微信朋友圈场景，暴力滑屏列表有几率出现闪白； 大量已知尺寸的图片长列表、纯文字长列表，性能还可以接受 一个页面用 Native 还是 RN 来实现，除了考虑各端团队人员配比，业务场景也是一个重要的考虑因素。譬如新项目中，作品详情页用 Native 或 RN 实现都能达到验收目标，但考虑到作品详情页产品场景已经很成熟，且有不少模块与核心阅读页有较多的交互，对体验要求也特别高，我们与终端团队一致选择 Native 来实现。 写在最后近期 Airbnb、Udacity 团队纷纷表示弃用 RN，笔者认为大家大可不必为此忧心忡忡。Airbnb 列举的条例，其中不少项是可优化，或者结论是有待考究的；另外一些也有公司内部自身存在的问题。最近 Facebook 团队宣布正在努力打造一次大的升级，其中提到的对线程模型、异步渲染和桥接的优化方向，也让我们十分期待，我们有理由相信 RN 的未来会更好，也希望能通过这篇分享有更多的同学加入 RN 的大家庭，共同打造更好的 RN 生态。]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>Hybrid</tag>
        <tag>App</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[起点海外版 Hybrid App－内嵌页优化实践]]></title>
    <url>%2F2018%2F06%2F25%2F20180625%2F</url>
    <content type="text"><![CDATA[今年年初我司开启了起点品牌的海外之旅，名为「 Webnovel 」。 目前 PC / M站 / App 三端都在快速的迭代中。而其中起点海外版 App 是基于 Hybird 技术进行开发的。作为起点海外 Hybird App 中内嵌页的前端开发，从 1.0.0 版本的陌生，到最近发布的 2.0.0 版本的娴熟，海外版内嵌页的开发方式一直都在改进，力求最大程度的接近 Native App 的页面性能和用户体验。 在开始讲解起点海外版 App 中内嵌页的具体实现以及优化之前，让我们先来了解下整个 Hybird App 实现的具体方案。 一、Hybrid App 实现方案1. 什么是 Hybrid App ？Hybrid App（混合模式移动应用）是指介于 WebApp 、Native-App 这两者之间的 App，兼具「 Native App 良好用户交互体验的优势 」和「 Web App 跨平台开发的优势 」。 2. 为什么选择 Hybrid App Web 实现相对简单，一套代码，两端兼容； 产品还在快速迭代，变数大，而 Native App 开发，成本偏高； Web 开发时间较短，减少成本，可以应付产品的快速迭代； Hybrid App 的开发方式在公司其他项目上已经有了很好的运用，技术方案已有沉淀； 以上几点，是促使海外版 App 使用 Hybird 模式进行开发的主要原因。 二、整体架构 1. Hybird 实现方案Hybird App 是使用 iOS 原生 、 Andoird 原生 、Web 页面 「 内置于 App 中的页面，既内嵌页 」一起实现的方式进行开发。 2. 完整的SDK工具 离线包：Web 页面资源以离线包的形式内嵌在 App 本地存储中。当访问页面的时候，WebView 对于本地存储的资源无须额外发起的网络请求，直接读取。而剩下的请求中，就只剩下 Ajax 拉取的 Json 动态数据，和渲染这部分数据时携带的图片资源，以及一些必要的埋点请求。这使 Web 页面即是在弱网的情况下也可以很快的打开； 完善的JSSDK：使用 JSSDK 与 App 进行交互，透明且跨平台地使用客户端的能力，形成交互闭环，给用户良好的交互体验； 离线包打包工具：自动化打包工具能快速的产出离线包。没有了人工干预，App 离线包正确性也能得以保证； 完善的热更新机制：App 客户端监测到离线包更新之后，客户端静默更新（用户无感知），解决了 Native App 页面不能补丁更新，只能发版修复 Bug 的问题； 3. 完善的后台系统平台 一键打包：内嵌页离线包打包工具可视化，实现一键打包产出离线包； 降级融灾：快速回退至之前版本，如有问题，快速下线新版本功能； 数据采集：完善的数据采集平台，通过数据分析优化用户体验； 灰度更新：支持根据配置进行灰度更新； 持续集成：系统平台目前还在持续集成当中，为提供更好的开发流程； 三、内嵌页的优化我们起点海外 App 大部分页面都采用 Hybird 实现的，对于最大程度的接近 Native App 的页面性能和用户体验这两个点，我着重讲解下面两个部分： 内嵌页全局优化－接口页面并行加载； 详情页加载优化－ localStorage ； 1. 内嵌页全局优化－接口页面并行加载之前内嵌页的开发方式，是在 JS 中发出 Ajax 请求拉取数据，然后使用模版引擎拼接模版，插入到页面中，再由 WebView 进行页面渲染。 从上图我们可以看到，虽然页面很快就有了占位显示，但是整个操作是串行的，需要等到 Ajax 数据返回之后才能看到页面。而这个从 WebView 到发起 Ajax 请求之间的时间是被浪费掉了的。 如果当 WebView 启动的时候就能发送当前页面的 Ajax 请求，我们的数据就可以提前拿到了，而这样从启动 WebView 到 Ajax 发请求的之间的空闲时间，就被我们利用上了。此时上面的流程就变成了如下的样子： 当 WebView 启动的时候，App 根据 Url 地址获取相应的 Ajax 请求的地址，从而提前发出请求，等到页面本身请求发出的时候，拦截 Ajax 并判断是否是已经提前请求过的数据。如果是则基于提前请求的 Ajax 返回的数据渲染页面，如果不是则继续发送 Ajax，等到数据返回之后，再进行页面渲染。 上述做法，我们充分利用了 App WebView 的启动到 Ajax 发送获取数据之间的时间。接口请求与页面并行加载，加快了页面显示。 根据上组数据我们会发现页面显示的平均时间几乎快了 300ms 。在不影响页面正常加载流程的情况下，把串行操作变成并行操作，充分利用空余时间，大大缩短内嵌页白屏时间，让用户更快的看到了我们起点海外 App 的页面内容，效果显著。 2. 详情页加载优化－ localStorage采用接口与页面资源并行加载的方式，使内嵌页呈现的速度快了很多，但是由于海外用户区域广泛，接口加载时长的不确定，页面还是会有白屏的情况，接下来我们要做的就是特定页面，特殊处理。 再整个起点海外 App 页面中，详情页访问量相对较大，也是整个站点中比较重要的页面，所以其页面呈现的速度至关重要。因此本次迭代我们主要针对详情页做了特殊处理。 首先，我们先分析一下详情页的业务形态。书详情页数据相对比较稳定，并不会频繁变化，但接口数据返回需要时间，那我们是不是可以让书详情页的数据先本地存储，以求达到快速显示的效果，并同时发出 Ajax 接口，等到数据返回时再纠正页面上旧的数据。 关于本地存储，我们引入 localStorage 来进行本地存储，原因如下： localStorage 可以存储的数据容量大； localStorage 属于永久性存储； localStorage 目前移动端浏览器支持度良好； 从上图我们可以看到，当用户第一次访问书详情页时，localStorage 中没有相应书籍数据页面按正常逻辑显示，但这时我们会把这份数据缓存到 localStorage 中。当用户第二次访问同一本书的详情页时，我们根据 bookId 的 Key 值在 localStorage 中快速找到相应书详情页信息数据，并基于该缓存数据拼接模版，渲染页面。同时继续发出 Ajax 请求，待数据返回时，与 localStorage 的数据基于 Diff 算法进行对比。如果数据一致，则不做任何处理，不一致则页面基于新数据重新渲染，并且更新 localStorage 中的数据为新的 Ajax 返回数据。具体效果对比图如下，左边是未做二次加速的，右边是使用了二次加速的效果： 可以看到页面第一次展示的时候，依然能够明显看到占位图，但是当页面二次打开就直接呈现，效果很明显。 结尾～～做了半年多的 Hybird 页面的前端开发，针对海外版 App 做了很多的优化，为的是给用户带来更好的体验。但对于 Hybird 技术自身的瓶颈，我们也无能为力。所以目前我们团队在尝试从 Hybird 到 React Native 的技术转型，以求能够在用户体验上更进一步。 同样延续上一次的分享：一个细节的优化是可以决定产品的好坏的，良好的用户体验，会吸引跟多的用户，获得更多的称赞。 以下是起点海外版的访问地址，请使劲戳戳戳～～～👇 起点海外版 App下载：请前往 Google play ／ App Store [ 美区 ] 下载 起点海外版web站：https://www.webnovel.com 起点海外版m站：https://m.webnovel.com]]></content>
      <categories>
        <category>Hybrid</category>
      </categories>
      <tags>
        <tag>用户体验</tag>
        <tag>Webnovel</tag>
        <tag>Hybrid</tag>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是时候好好安利下 LuLu UI 框架了！]]></title>
    <url>%2F2018%2F06%2F22%2F20180622%2F</url>
    <content type="text"><![CDATA[你问我有什么不同？只是更自由，更纯粹，和用户走得更近。 官方网站：https://l-ui.com/ 项目主页：https://github.com/yued-fe/lulu API文档：LuLu UI API中文文档 你好，LuLu！LuLu UI 是一个基于 jQuery，针对 PC 网站，兼容 IE8+ 或 IE7+ 的前端 UI 框架，包含 20+ 静态或动态 UI 组件。 贴近用户LuLu UI 更温暖，更自然，更亲近，更关注细节和用户体验，对用户侧非常友好，因此，非常适合面向外部用户的网站开发。有别于 Ant Design 这类更适合中后台开发的UI框架。 上手简单LuLu 整个项目就是提供一些 UI 组件的 JS 和 CSS，很纯粹的 JS 和 CSS，没有任何矫揉造作的“变身”处理。 因此，想要使用 LuLu UI，直接引入 CSS 和 JS 文件地址就可以使用了。HTML还是原来的 HTML，CSS 还是原来的 CSS。什么 Vue 什么 MV* 什么高大上概念完全不需要掌握，参照文档，复制复制，粘贴粘贴，效果就出来了。 API 文档参见：LuLu UI API中文文档 使用场景广泛LuLu UI 既保留了 jQuery 插件即插即用的特性，也支持适合多人合作的模块化加载方式，因此适用场景更加广泛。 例如： 单人完成的某个简单运营活动页，需要个弹框提示功能，可以直接引入 LuLu UI 中的 Dialog.js，就可以使用了。 某网站看中了 LuLu UI 某一个组件，例如日期选择功能，想拿过来使用，&lt;script&gt; 引入日期选择 JS，然后就可以使用了。 对于多人合作大型项目，可以使用类似 seajs 这样的加载器进行模块化加载与开发。 所有组件无论是单独使用，还是体系内使用，文档均提供了 demo 演示。 成熟LuLu UI 2015 年就诞生了，到现在已经有 3 年了，跟那些年轻的 UI 框架不同，LuLu UI 可是见过很多世面的，谦逊内敛不聒噪，没必要大肆鼓吹，口碑说话。 开源是件严肃的事情，LuLu UI 一直认为，如果组件还没有达到不动如山的境地，那就应该继续埋头打磨。这么多年过去了，经过对内对外多个大中小型项目的验证与打磨，无论是交互细节还是代码本身细节，LuLu UI 现在都已经可以做到不显山露水了。 体验好LuLu UI 不会把什么“极致体验”挂在嘴上，极致是没有尽头的。LuLu UI 也就做到用户使用无感知这种程度。 举个例子，如果用户是通过鼠标点击按钮打开的弹框，则弹框界面平平无奇；如果用户是通过ENTER回车键点击按钮打开的弹框，则弹框中的按钮默认会 outline 高亮！ 见下面截屏示意： 除了多年不断优化的无数交互小细节，LuLu UI 还适配 retina 视网膜屏幕，同时支持屏幕阅读设备无障碍访问，以及很少 UI 框架支持的 keyboard 键盘无障碍访问。坐下，坐下，都是基本操作而已。 代码学习素材LuLu UI 的 JS 代码非常适合萌新参考与学习。 层次简单，逻辑清晰，注释详尽与规范，代码朴实无华，没有炫技，非常适合阅读和理解，是不可多得的学习素材。 与众不同的设计思想表现为3点： 面向设计理念； 没有版本概念； 面向HTML开发 面向设计理念让 LuLu UI 在视觉和交互表现上更有情感，更有温度；摒弃面向功能那种大而全开发思想，于是 LuLu UI 的代码更加简约，组件更轻便灵活。 LuLu UI 框架是没有版本的概念，只有一个唯一的母体在慢慢迭代。当面对一个新的项目，拷贝这个母体，然后这个拷贝的 LuLu UI 就和项目耦合在一体，与母体没有任何关系，你就可以根据设计需求、产品需求任意修改项目中的 LuLu UI 的 CSS 和 JS，从而保证视觉还原，产品品质和开发质量。 面向 HTML 开发，使得 LuLu UI 更语义，对辅助设备更友好，同时技术栈更偏向 HTML 和 CSS，也使得广大 JS 相对偏弱，在视觉表现较强的前端更容易上手，可以更友好地还原设计和增强体验。 LuLu UI 所有与众不同的设计思想，都是方便外部用户，方便体验侧前端同学进行开发，方便设计师视觉还原和创意实现，归根结底可以有更好的用户体验和产品品质。如果是面向中后台开发的UI框架，则会面向数据，面向功能设计，组件应用会规避书写 CSS 和 HTML，以方便开发侧前端同学进行开发。可见不同产品形态和不同用户群体决定了不同了 UI 框架设计理念。 设计师同事一定会很喜欢 LuLu UI 框架的。 稀缺性既懂设计又会代码同时在体验方向有较多积累的前端是稀缺的。所以，LuLu UI 也是稀缺的，在 PC 端用户侧网站开发上，LuLu UI 有着不可匹敌的竞争力！ 阅文前端荣誉出品感谢前腾讯诸位同事，现阅文诸位同事在 LuLu UI 建设上的帮助。 标签： LuLu, UI, 屏幕阅读器, 无障碍网页应用, 框架, 用户体验, 键盘]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>LuLu</tag>
        <tag>UI</tag>
        <tag>屏幕阅读器</tag>
        <tag>无障碍访问</tag>
        <tag>框架</tag>
        <tag>用户体验</tag>
        <tag>键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读体验优化之起点阅读页]]></title>
    <url>%2F2018%2F06%2F15%2F20180615%2F</url>
    <content type="text"><![CDATA[阅读页作为小说阅读类网站访问量很高的页面，阅读体验上的优化是至关重要的。我有幸在起点项目中负责阅读页的前端开发，成就感满满。 起点中文网访问地址：https://www.qidian.com ，欢迎体验！ 在整个起点项目已经有很完善的性能优化体系的情况下，阅读页在改版之后，页面性能统计数据如下： ▲ 上报系统统计数据 ▲ 全国访问速度均值 10% 采样结果 由上组统计数据我们可以看到，起点中文网阅读页平均 DOM Ready 的时间为 0.2s ，Onload 的时间为 0.9s ，加载最慢地区页面 Onload 时间也仅为 1.44s 。 这已经充分体现了起点中文网阅读页的优异性能，本篇着重探讨在页面性能已经如此良好的情况下，如何进一步的优化起点中文的阅读体验。本次优化侧重在以下两点： 一、章节加载逻辑优化； 二、滚动加载优化－函数节流； 一、章节加载逻辑优化通常用户在阅读完上一章之后，会明显的看到我们加载下一章的 Loading 状态。这对于用户体验来说影响是比较大的。如果能在用户触发到某一特定时间点的时候，就提前加载好下一章节内容，用户停留在 Loading 的时间就能明显减少甚至感知不到。这种体验上的优化我们称之为无缝阅读。基于这个点我们采取了如下的两种方式： 适当提前 Scroll 触发加载时机； 持续预加载后面章节数据； 1. 适当提前 Scroll 触发加载时机什么是触发加载时机提前？即当你预知到加载即将被触发，就提前触发当前事件，这可以大大减少用户等待的时间。 起点中文阅读页提前触发事件的机制是，当页面剩余高度小于等于页面视窗的 1.5 倍时，就立即加载下一章节。 可以看到实现原理其实很简单，就是达到触发点去拉取下一章节，实现代码如下： 12345678910111213141516171819202122// 使用函数节流的形式监听scroll事件$(window).on('scroll', function()&#123; // 获取当前页面高度 var pageHeight = $(document).height(); // 获取滚动条距离页面顶部的距离 var winSTop = $(window).scrollTop(); // 获取浏览器高度 var winHeight = $(window).height(); // 当页面未显示高度页还剩1.5倍视窗高度时,加载 var cHeight = 2.5 * winHeight; //当剩下小于1。5屏未显示的时候,加载新的章节 if( pageHeight &lt;= ( winSTop + cHeight ) )&#123; // ... do somethings &#125;&#125;);// 页面初始化的时候主动去触发一次scroll事件$(window).trigger('scroll'); 当写完上述代码后，会发现页面加载下一章节变的快多了，但是在滚动很快的情况下或者数据接口返回较慢的时候，页面还是会显示 Loading 态，如下图所示： Loading 会 Block 阅读进度，影响用户阅读心情。所以在这种情况下，我们引入第二个体验上的优化点。 2. 持续预加载后面章节数据什么是预加载？ 提前加载数据，当用户需要查看时可直接从本地缓存或者内存中读取。 为什么需要预加载？ 可以从缓存中读取数据，不通过网络传输，速度更加快，无延迟。 利用用户阅读的空余时间，提前加载下面一章节的信息存入内存中，减少用户等待 Loading 的时间，从而达到进一步提升用户体验的目的。 ▲ 预加载逻辑流程 上图描述了我们利用内存存储下一章数据的流程。下面具体来看一下代码的逻辑： 1) 首先页面 Load 完之后立马加载一章节内容存储在内存中； 12345678var chapterInfo = &#123; // 标示字段中是否有 章节存储 isHas: boolean, chapterId: 21463, content: ''&#125;;// 是否正在预加载标识var chapterLoad = false; 2) Scroll 滚动触发逻辑 ，添加预加载章节逻辑，保证页面加载无断续状态。代码如下： 12345678910111213141516171819202122232425262728293031// 使用函数节流的形式监听scroll事件 $(window).on('scroll', function() &#123; //当正在加载章节时,不再加载下面章节 if (that.chapterLoad) return false; // do something ... // 当剩下小于1.5屏未显示的时候,加载新的章节 if (pageHeight &lt;= (winSTop + cHeight)) &#123; // 当内存中有章节存储 &amp;&amp; 储存的章节id === 下一张展现至页面上的章节id if (chapterInfo.isHas &amp;&amp; chapterInfo.id == nextChapterId) &#123; // 把内存中的章节append 至页面中，并清除chapterInfo参数中的数据 &#125; else &#123; // capterLoad 置为true,禁止发送请求 that.chapterLoad = true; // 发送ajax请求 加载数据 append 至页面 &#125; &#125; else if (!chapterInfo.isHas &amp;&amp; !that.chapterLoad) &#123; // 当内存中没有章节信息 &amp;&amp; 没有章节正在加载时 进行预先加载 //重置为true,禁止发送请求 that.chapterLoad = true; chapterInfo.isHas = true; // ajax拉取章节信息至内存 ，并设置 that.chapterLoad = false // 在数据返回存入内存后，回调中主动触发一次 window.scroll 事件，防止在ajax请求时还未返回数据时， 页面已经滚动至底部不再触发scroll 事件，页面出现加载停滞情况 &#125; &#125;); 从上述代码可以看到预加载和直接 Append 数据至页面中的逻辑是互斥的，既保证页面逻辑清晰，也优化了页面阅读体验，达到我们预期的效果。现在我们来看下页面滚动的效果： 页面加载下一章节的时候几乎没有 Loading 态显示，赞！ 二、滚动加载优化－函数节流做了上述优化之后，页面滚动加载已经很完美了，这个时候我们可以去思考一下代码层面上的优化。在前端领域中滚动加载是一个十分常见的加载机制。监听 window.scroll 事件，判断当前是否到达触发加载的时机，加载后面一段内容。常见的监听事件代码为： 123$(window).on('scroll',function()&#123; // ... do somethings&#125;); 上诉章节预加载就是使用这种 Scroll 监听方式。 但是 window.scroll 事件监听是实时触发的，也就说每隔 16.7ms 就触发一次，单位时间内事件触发的次数过多，会影响系统性能。此时函数节流是一个不错的解决方案。 函数节流是什么意思呢？好比生活中拧紧水龙头的过程，在拧紧这个动作中，我们单位时间内流出的水就会减少，从而达到我们节流的目的。 在代码逻辑中我们通常预先设定一个执行周期，当调用动作的时刻大于或等于执行周期时则执行该动作，然后进入下一个新周期。 我们通过设置一个合适时间间隔来执行 Scroll 事件，以减少请求增加性能。在停止 Scroll 滚动之后，再触发一次滚动事件，处理滚动时机不对，触发不及时的问题。定义一个节流函数，如下： 123456789101112131415161718192021function throttle(func, wait, mustRun) &#123; var timeout, startTime = new Date(); return function() &#123; var context = this, args = arguments, curTime = new Date(); // 清除定时器 clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if(curTime - startTime &gt;= mustRun) &#123; func.apply(context,args); startTime = curTime; &#125; else &#123; // 没达到触发间隔，重新设定定时器 timeout = setTimeout(func, wait); &#125; &#125;; &#125;; 监听滚动的方式就可以优化成： // 使用函数节流的形式监听scroll事件 $(window).on('scroll', throttle(function () { // do something }, 200 ,300)); 如下所示，左边是普通 Scroll 事件触发的方式，右边是使用了节流函数触发的方式。使用节流函数的方式明显减少了事件触发的频率，并且在停止滚动的时候也会触发一次 Scroll 事件，防止错过一些特殊的情况，未能执行页面下拉加载事件。 最终我们在没有影响页面滚动加载体验的情况下，节省了浏览器的性能开销，完美。 结尾第一次做阅读相关的项目，并负责如此重要的一个页面，我融入了自己的想法，优化阅读体验，最终达到了我要的效果，我很满意。 一个细节的优化是可以决定产品的好坏的，良好的用户体验，会吸引跟多的用户，获得更多的称赞。针对阅读体验上的优化，我们其实能做的还有很多，希望之后可以再进一步的优化。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>用户体验</tag>
        <tag>scroll</tag>
        <tag>函数截流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动效是种浪漫－起点国际浪漫之旅]]></title>
    <url>%2F2018%2F06%2F07%2F20180607%2F</url>
    <content type="text"><![CDATA[经过短暂的迭代，起点国际版 PC，iOS，Android，M站都已火速上线，喜大普奔，普天同庆。 一个偏体验的前端程序员，今天要谈的不是代码而是起点国际的动效。 什么？你还不知道我说的是什么？ 链接走起来： 起点国际 PC https://www.webnovel.com/ 起点国际 M站 https://m.webnovel.com/ 你先体验一下，再听我仔细道来。 一、初见动效顾名思义就是动画效果。网页中为什么需要动效呢？简单来说就是为了有趣。 如果把网页和用户的关系比做正在恋爱的情侣，很显然网页的 UI 是颜值，而动效在我看来则是情侣之间的小浪漫。可能和颜值比起来，浪漫似乎并不是那么的重要，但是如果感情中没有了浪漫，是不是会觉得少了点什么呢？ 初次和女神见面的时候，我们总是会精心的打扮，但是如果我们能顺便带上自己的幽默感，是不是会更加让女神心动呢？在网站的初期我们都会特别的关注视觉，与此同时如果还能加上一点细致的动效则会更加的吸引人。 起点国际第一版登录页面的视觉设计非常好看，夜空高清的大图给人一种大气沉稳的感觉。但是老板说这并不能直观的表达出咱们是和书打交道的网站。作为全球知名的正版中文电子图书馆和国内热门的 IP 源头，我们希望用户能够在第一眼就知道我们是干什么的，我们的优势是什么，此时不断循环滚动的书封动效在这里就发挥了它极大的作用。 动效是一种网页和用户之间的浪漫。这种浪漫可以没有，但有一定是为了让用户更爽。而用户爽了就自然愿意为你的产品买单。如果我的这个假设成立，那么动效就变成了一道爱情题。和所有爱情问题一样，模仿一定是最简单的捷径。多向老司机学习把妹技巧和动效创意，下次在自己的实战当中就可以用到。 二、动效应有品味有的妹子喜欢小鲜肉，有的妹子偏爱大叔。作为浪漫制造者，我们必定要提前弄清楚妹子的口味。Apple 作为国际化一线公司选择了如下的动效风格。 第一次看到这个效果整体给我的感觉像是一个舒缓而沉稳的大叔。而大叔给人的印象通常都会是安全感。安全感同时意味着 Apple 的产品信得过，值得大家购买，而这正是 Apple 的套路。 简单来说动效的速度反应着一个网页的气质和品味，快的动效相对来说会显得活泼可爱，慢一点的动效则会显得更加沉稳大气。 起点国际是一个面向海外的在线阅读平台，我们希望能给读者带来最全面、最精准、最高效更新及最便捷的体验。但是和 Apple 这个成熟大叔比起来，我们只能算做一个小鲜肉。如果一个小鲜肉装成熟难免会给人油腻的感觉。所以起点国际的动效整体感觉是轻快愉悦的。你不会在整体上看到太多复杂的效果。但是你动一动，点一点就会发现我们给你藏下的玫瑰。 三、动效应保有距离在刚开始追女孩子的时候，我们往往更希望妹子们能够看到我们的真诚和真心。如果一来你就送女孩珍珠和项链，我相信大多数女孩还是容易被吓到的，而那些没有被吓跑的女孩，你后面要送什么？ 所以前期我更推荐小而美的东西，这样既不会显得太突兀，也比较能够让人接受。当然也不是说咱们不能玩儿点大的，在这节奏匆忙的互联网时代，大家什么妖魔鬼怪没有见过，但这得是在彼此建立足够多的信任之后才可以挑战的事情。 好比平时循规蹈矩的程序员男友，天还没亮就拉着女朋友的手，也不管妹子的起床气和疑问直接载到山顶。当太阳出来的那一刻我相信女孩会被融化。但如果这个男友换成就见过一次面的朋友。可能大多数人心里还是拒绝的。 这也是起点国际初期并没有选择加入太多酷炫的动效的原因。当然还有一个原因是为了和大家快点见面，我们把需要花时间和精力研究的酷炫效果留在了后续的迭代当中。毕竟先让大家看到我们，我们才有机会给大家展现我们其他方面的优点。太急于展现自己，反而会显得不尊重对方，保持人与人之间应有的距离，才能让彼此关系更长久。而这也说明动效是一件和浪漫一样需要花时间和心思才能完成的事情。 四、动效应贴心请客的男生满天飞，入座的时候主动为女生搬椅子的帅哥却没有几个。既然我们大家都做得一样，那么女生在选择的时候就只能看颜值了。所以细节此时就显得特别重要了。初次见面你送女生一支玫瑰，出门随身揣一包纸巾，或者在就餐的时候把女生喜欢吃的菜安排在她的容易夹到的位置。这些细节都是能够给你加分的项目。 起点国际的页面承载着非常丰富的内容，但这同时意味着咱们的页面会相对较长，当用户想回到顶部的时候还得拖动滚动条，这明显比较的麻烦。我们的做法就是在页面滚动到超过一屏的时候显示一个返回顶部的按钮，点击之后页面滚回到顶部按钮消失。按钮出现和消失，都是采用和页面滚动一致的滑动效果，既起到提醒用户这里有一个按钮的功能，又不会让这个按钮出现的时候显得太过生硬。 酷炫的动效当然可以吸引人，但是我们往往容易进入为了酷炫而酷炫的坑，反而忽略掉细节。我们通常会在按钮 hover 的时候给到一个动效，也能把这个效果做得很赞。但是按钮可不止 :hover 这一种状态，:active、:visited、:disabled、:focus 这些也同样是我们需要考虑的细节。 有的人可能会觉得考虑到这么的极致是不是一件值得的事。我们喜欢一个人的时候，不会考虑做这些事情是不是值得的，即使明知道对方可能并不一定会看到。但是，如果对方看到了呢？这是什么？这就叫贴心。贴心这种东西，有的时候我们感觉不到，但是只要对方感受到了就会放大其它所有的好。而这也是网页中的动效重要的地方。我们为别人考虑的越多，别人自然也会记住我们的好，这是再简单不过的道理了。 五、动效应特别老司机的套路千千万，我们可以学习的可不止一种。这里我拿网页中常见的下拉菜单举例。我们要做的事也很简单，就是用户在点击按钮之前让下拉菜单不可见 ( display:none ) ，移入按钮可点区域的时候显示 ( display:block ) ，这样我们功能的需求就实现了。可是这还不够，女朋友让你去倒杯水，你就傻傻的给她倒了一杯水放到了她的面前。这样并不会让妹子开心，因为这样一点也不浪漫。 女生让你倒杯水有可能是大姨妈来了不好意思告诉你，此刻你应该拿出平时准备好的姜茶给她泡上。待姜茶稍微凉下来之后，你再端过去，抱住她喂她。还要假装这茶有点烫，给她吹一吹，关心的说：「宝贝，小心烫。」这看似戏剧化的倒水，虽然给人感觉有点作，但这相对来说会比较的浪漫。 我们的下拉菜单又何尝不能浪漫？在显示下拉的时候加一点透明度，是不是就柔和了？让下拉出现的时候再有一个上下的偏移，这样是不是就丰富了？再大胆一点我们让子元素出来的时候有一个先后顺序的延迟，这样是不是就更有层次了？如果想要更酷炫，甚至可以考虑一些 3D 的效果。 CSS 强大的地方在于我们对几乎所有的DOM属性都有操作的能力。时间，透明度，大小，位置，颜色，速度，甚至是 3D 等等我们都是可以尝试的。甚至组合控制不同的属性，还会出现意想不到的效果。 别人送花，你也送花，这怎么能体现出自己的优势？要让女神在众多追求中看到自己，就不要送花，我们送口红，这样会不会显得自己很特别，很有品味？ 当然这种特别的尝试都是需要符合接下来要讲的用户预期的。你女朋友可能真的只是口渴这么简单，你给她搞这么一出浪漫，那明显就是戏演过了。女神可能喜欢的是少女粉色号的口红，你却送了一只姨妈红，这就弄巧成拙了。 六、动效应符合预期你和你的女朋友在繁华的街道逛街，突然你华丽转身，对着你的女朋友唱起了《Marry Me》，然后单膝下跪，从胸口掏出了一个精致的盒子。此时你们周围已经围满了人，你的女朋友也激动得眼睛有些湿润。你打开盒子，里面什么都没有「Tada！ 愚人节快乐！」我想此刻你女朋友心中一定有一万匹羊驼狂奔。 再转回到我们网页的场景当中，相信很多人和我一样，本来打算下载一个起点国际的阅读 APP，好不容易进入到了一个下载的界面，超大的下载按钮让我看到了希望，我点了下去。哐当！一个有声的全屏视频广告炸了出来。我急忙关掉。然后再点一次下载下来一个安装文件。好不容易安装好打开一开，XX是一个流氓软件。 以上两个都是属于不符合用户预期的行为，这很容易引起用户的不适，甚至是反感。因为说得严重一点，这其实叫做欺骗。让人喜欢你很难，但让人讨厌你是轻而易举的事。一旦用户感觉自己上当了，你之前所有的努力就都有可能白费。 如何将这种效果衍生到我们的网页中呢？起点国际在很多鼠标交互的地方，都统一采用的是鼠标移入的时候添加阴影，按下的时候变小的方式。设想一下桌上放了一块 QQ糖我们准备用手去捏它。当我们手移过去的时候会挡住光，所以会看到阴影，捏下去的时候，因为用了劲所以糖被捏扁了。这是不是比较符合我们对按下这个动作的预期？冰冷的网页应尽量用动效去贴近我们的生活，降低用户的理解成本，减少用户在你页面效果上的迟疑。而这也是拟物为什么始终是培养用户习惯的首选设计风格的原因。 当然这只是万千场景中的一种，根据我们预设的场景不同，我们的动效也需要相应的调整。你也可以设想我们鼠标点击的过程是一个在平静湖面扔石头的场景，当鼠标按下，按钮出现一个逐渐扩散的阴影，以模拟湖面涟漪的效果。这也是非常不错的一个选择。 七、动效应始终如一这个比较像我们和女朋友聊天。前一秒你们诗词歌赋人生哲学聊得正嗨。突然你话锋急转聊起了昨天来你家的某个亲戚很让人讨厌。这种聊天方式我相信没有几个人能够招架的住。话题和话题之间应该有一种起承转合的联系，这样才不容易把天聊死，这在我们动效当中也是同样的道理。 点击按钮和弹出弹窗这两个动作其实本身是没有太大联系的。我们点击按钮可以触发的事件太多了，弹出弹窗只是其中一种而已。但我们的需求又是如此。所以我们建议用动效去拉近它们之间的关系。人与人相处有一个类似的道理，我重复你的动作就是为了和你拉近关系。女神给你眨了一下眼睛，你自然会想到赶紧给女神也抛个媚眼。路人给了你一个微笑，你自然也是会回敬一个微笑。重复让原本陌生的两个人有了联系，也可以让两个没有关系的操作有联系。 之前我解释过起点国际对于按下这个动作的处理方式是鼠标按下变小移开变大，延续到弹窗我们让弹窗顺着按钮变大。因为弹窗出来的时候是由小变大，那么关闭的时候自然就想到由大变小。这样我们的动效就只有由大到小，和由小到大一种交互形式，用户的认知成本也大大降低。并且重复是一个可以节约开发成本的事，一举两得何乐而不为呢？ 从一开始我们几乎不知道怎么做动效到后来知识储备越来越多，我们总是会希望能够小小的炫耀一下。但是我们知识的来源往往是不同的网站或者不同的大神。我们把他们的优势统统的拿过来放到我们的网站中，就容易在我们自己的网页上出现百花争艳的状态。局部看美极了，但整体用起来总是觉得怪怪的。混搭可能很惊艳但很难高级。 重复可以达到统一整体风格的目的，如果有的地方不能做到重复，我们也尽量应采用速度一致或风格相近的动效，以求达到整体的一致性。而这种一致性带来的舒适感，可能比酷炫带来的惊喜，更容易留住我们的用户。 八、动效不应制造麻烦当我们和女朋友准备出门的时候，女生往往都会精心的打扮一下。「亲爱的你看我是穿这条粉色裙子好呢？还是这条蓝色的裙子好呢？」通常这样的问题，对于一个完全不懂打扮的 “程序猿” 来说简直就是噩梦。你说选粉色吧「不行，这个颜色太嫩了，不适合我。」你说选蓝色吧「这个颜色和我的皮肤不搭。」然后你们就在这个问题上不断的重复，轮回。最后你女朋友会在生气的妥协当中陪你出门，可是这一切你也无能为力。 在我们的网页中如果同一时间给用户的选择越多，用户一个都不想选的几率就越大。所以我们要做的是在交互上尽量减少选择，在动效上弱化选择给用户带来的恐慌。 起点国际首页 Banner 上的按钮默认是不显示的，用户鼠标移入到 Banner 区域，我们认为用户有了切屏的意愿，此时再显示我们的按钮，并且按钮出现的时候我们用动效让右侧按钮比左侧按钮先出现。这样即契合我们第六点讲到的符合用户预期，也避免了视觉上同时出现的选择给用户带来的焦虑感。完美！ 在一起 我们花那么多的时间，相识，相知，中间绞尽脑汁的彼此套路，最终目的都是希望对方感受到我们的用心然后和我们在一起。透过动效，我们希望用户也能够感受到我们的真诚与善意，不求能与用户天长地久，只求用户能在我们这个书的城堡中有一场浪漫的旅程。]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>animation</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哇牛叉学院之基于 VoiceOver 的移动端无障碍阅读访问]]></title>
    <url>%2F2018%2F06%2F04%2F20180604%2F</url>
    <content type="text"><![CDATA[本集出场人物：米亚、起床气、5号、阿力、软大特别感谢：馒头 今日，学院布置了一个新任务，要去佘山拜访一位名为『飞天蝙蝠』的前辈，亲自上门取一件重要的宝物。并特别指定了『米亚』『起床气』『5号』三个感知型同学前往，同时安排『阿力』一同前往，保护诸位同学以及宝物的安全护送。至于这个宝物是什么，上面并没有明说，只是说到了那里自然就会知道。 按照地图指引，穿过眉公钓鱼矶，黄巢洞，远远就看到一座古味浓郁的联排建筑，走近一看，『飞天山庄』，哈，就是这里，正要敲门，突然就传来缓慢但略显尖利的声音：「来着何人？」 「前辈你好，我们是『哇牛叉学院』的学生，过来拜访前辈，顺便取一件宝物。」 「亮出凭证。」 『米亚』取出收据，正要奇怪给谁的时候，突然门就开了，「你们进来吧，直接去大厅，我稍后就到！」 片刻后，一位三四十岁中年人左手抓着个白色的盒子快步进来，直接坐在了主座上。突然大伙心中一惊，因为大家发现这人的眼睛全白，略显瘆人。于是，『5号』忍不住问道，「请问您是『飞天蝙蝠』前辈？」 「你难道感觉不出来吗？」 「这…」，突然的一顿憋让『5号』一时不知如何，结果好死不活又问了句，「前辈是不是有眼疾？」 「哈？你感觉不出来，难道还看不出来吗？」 「…」，突然发现这人都这么冲，大家都没在说话，反而老者先开口了：「剩下的一半钱款和刚才订金的收据留下，这个你们学院要的‘货物’就可以拿走了。」 大家互相看了看，估计心中的想法都是一样的，咱们赶快人完成任务，赶快撤，连口茶都没有的地方，实在没有久留的必要，「好！」只见『米亚』拿出一个小瓶子压住订金收据，回复道，「这是你要的东西，前辈！」 只见中年人右手准确抓起小瓶子，然后立马一层浅浅的『泉之力』包围这密封的放置『泉钻』的小瓶子，眉头一皱，似乎在发力，然后立马又舒展开，「恩，不错，你们学院产出的‘泉钻’品质还是一如既往的好，东西你们可以拿走了。」说完左手一扔。 我擦，众人心里一万个草泥马奔过，这么贵重的宝贝居然扔得这么荡气回肠，可是值我们一年的工资啊！ 好在『阿力』反应快，稳稳接住了，不然就玩大发了。 「那好，前辈，我们还有事就先告辞了！」说完，众人起身准备离去，刚走出去没几步，背后就传来尖利地听起来怪怪的声音：「你们不验货倒是看得起我，我倒是蛮开心的，但是就是不知道没有我的指点，你们中有没有人会使用这个东西呢？」 众人一听立马停住了脚步，正在疑惑之时，又有声音传来，「你们学院应该把感知型学生都安排到这次任务里面了吧，难道你们认为这是巧合？」众人面面相觑，中年人继续道：「不管怎样，货还是要验的，不然你们出去被调了包，岂不成了我的锅？」 恩，说得很有道理，于是，大家又都回到座位上，当着中年人面打开那个白色的盒子，结果映入眼帘的是一个巴掌大长方形薄薄的有圆角的物体，有明显的正反两面，反面还有一个缺了一口的苹果图标。 中年人自己主动开口了：「这就是我花了数年时间制作的无障碍访问神器，我称之为 iPhone，特别适合感知型异能者使用，通过特定操作把感知到的精灵波动输入其中，就可以大致知道精灵的想法，我现在就教你们如何使用。」 先了解一些 ARIA 无障碍和 VoiceOver 的基本知识首先，你们需要了解无障碍访问中的 ARIA。 ARIA 全称 Accessible Rich Internet Applications(可访问的富互联网应用)，在当下讨论 ARIA 基本上都是为读屏设备或软件，而读屏设备或软件的使用者多是视力障碍人员，因此，ARIA 约定俗成就成了对视障用户的无障碍访问支持技术的代称了。 首先，了解下常见的读屏软件，如下列表： 移动端： Android: TalkBack Android: Funtouch iPhone: VoiceOver 桌面端： Windows: NVDA, JAWS Chrome: ChromeVox OSX: VoiceOver ARIA 总共有3大部分组成，如下： role 属性值 aria 属性 aria 状态属性 这篇文章「WAI-ARIA无障碍网页应用属性完全展示①」有非常详尽的翻译展示，我这里列举一些常用的： role属性值 123456role=&quot;tab&quot;, role=&quot;button&quot;, role=&quot;radio&quot;, role=&quot;checkbox&quot;, role=&quot;link&quot;,… aria属性 1234aria-haspopup, aria-label, aria-owns,… aria状态属性 1234567aria-checked,aria-checked,aria-selected,aria-expanded,aria-hidden,aria-invalid,… 然后，需要知道如何开启 iPhone 的 VoiceOver ？ 最快捷的是使用 Siri，「打开 VoiceOver」，如果 Siri 卖萌说不知道 VoiceOver 是什么鬼？那就试试「请打开 VoiceOver」，或者手动开始，路径为：设置→通用→辅助功能→VoiceOver（在第一个，见下图） 在 iPhone上 VoiceOver 开启后，操作方式有个根本的变化： Touchstart 或 Touchmove 行为完全变成了内容识别与读取，没有任何 Web 交互行为的发生！ 如果你想点击某元素，必须先 Touchstart 或 Touchmove 选中，然后再双击，直接双击是没有用的； 如果你想滚动，三指滑动； 如果你想拖动滑块，先 Touchstart 或 Touchmove 选中，然后连续轻触并滑动（手指不要抬起）； VoiceOver 开启后的手势如下图： 所以，很多人不小心打开VoiceOver后发现关不了了，就是因为还是老的操作习惯。想要关闭，最快捷siri；如果只卖萌不行动，那就手动按部就班关闭：（轻触，再双击）设置→（轻触，再双击）通用→（轻触，再双击）辅助功能→（轻触，再双击）VoiceOver-&gt;（轻触，再双击）关闭。 下面开始教一些真正的实战。 基于 VoiceOver 的移动端无障碍阅读访问实战VoiceOver 下无障碍访问基础特性首先，大家应该都知道，HTML 元素还可以分为非替换元素和替换元素，常见的替换元素包括 &lt;img&gt;，&lt;input&gt;，&lt;img&gt;，&lt;button&gt;，&lt;iframe&gt;，&lt;video&gt;，&lt;object&gt; 等。 除了内容可替换以及一些CSS行为差异外，在ARIA无障碍访问这一领域也是有着巨大的差异的。 一. 非替换元素① touch页面任何区域一定会有信息读取！ 非 VoiceOver 状态，你点击页面空白，是不会有什么反应的，但是开启 VoiceOver 后则完全不同，Touch 页面任何区域一定会有信息读取，包括空白区域，而轻触空白区域的读取遵循下面2个规则： 就近原则； 穿透规则； 所谓“就近原则”，比方说点击下图所示的位置： 结果选中和读取的内容是“免费 链接 导航 标志性内容”，哪个近读哪个。 所谓“穿透规则”，比方说点击下图所示的半透明黑色蒙层位置，请问读出来的信息是？ 结果不是“信仰神国”，也不是“读至…”，读取的信息而是蒙层下面的图片列表信息！没错，直接穿透了。这个和正常浏览方式下的点击世界观是不一样的。但是，显然，此处穿透不是我们想要的，怎么避免呢？这个后面会介绍。 ② 必须有文字内容才会读取 1、如果元素不含文字内容，是不会读取的，例如，下图图标轻触是被直接忽略的： 相关HTML代码如下： 1234&lt;a href&gt; &lt;i class="icon-free"&gt;&lt;/i&gt; &lt;!-- VoiceOver忽略 --&gt; &lt;h4&gt;免费&lt;/h4&gt; &lt;/a&gt; 2、还没完，如果我们增加 title 属性描述内容，那会不会读取呢？ 1&lt;i class="icon-free" title="图标"&gt;&lt;/i&gt; &lt;!-- VoiceOver读不读呢？ --&gt; 答案是：依旧忽略！ 3、但是，有一个例外，那就是元素，如果这里的标签换成，则 title 属性就可以被 VoiceOver 宠幸。 1&lt;a href class="icon" title="图标"&gt;&lt;/a&gt; &lt;!-- 读：图标 链接 --&gt; 4、还是标签，但是，我们不是使用 title 属性，还是 ARIA 原生的规范的 aria-label 信息描述属性，那会不会读取呢？ 1&lt;i class="icon-free" aria-label="图标"&gt;&lt;/i&gt; 答案是：忽略，不会读取！ 5、 还没完，如果我们里面写入了文字，但是是 display: none 隐藏的，那会不会读取呢？ 123&lt;i class="icon-free"&gt; &lt;span hidden&gt;图标&lt;/span&gt;&lt;/i&gt; 答案是：忽略，不会读取！ 6、 还没完，如果我们里面写入了文字，但是是用的是 visibility: hidden 隐藏，那会不会读取呢？ 123&lt;i class="icon-free"&gt; &lt;span style="visibility:hidden;"&gt;图标&lt;/span&gt;&lt;/i&gt; 答案是：忽略，不会读取！ 7、 还没完，假设我们使用 text-indent 缩进让文字隐藏到屏幕之外，那总该要读取了吧？ 1&lt;i class="icon" style="text-indent:-999px;"&gt;图标&lt;/i&gt; 答案是：忽略，不会读取！ 8、 还没完，假如我们的 text-indent 缩进不要那么猛，仅仅是图标容器外，但是在屏幕内，那会不会读取呢？ 1&lt;i class="icon" style="text-indent:-10%;"&gt;图标&lt;/i&gt; 答案是：会读取！但是，选中时候的外框明显不在图标所在的位置，而是文字所在的位置。 9、 还没完，假设我们使用 CSS clip 属性隐藏，那会不会读取呢？ 123&lt;i class="icon"&gt; &lt;span style="position:absolute;clip:rect(0,0,0,0);"&gt;图标&lt;/span&gt;&lt;/i&gt; 答案是：会读取！ 10、 还没完，假设我们使用绝对定位屏幕外隐藏，那会不会读取呢？ 123&lt;i class="icon"&gt; &lt;span style="position:absolute;left:-999px;"&gt;图标&lt;/span&gt;&lt;/i&gt; 答案是：忽略，不会读取！ 11、 还没完，如果是相对定位屏幕外隐藏呢？ 123&lt;i class="icon"&gt; &lt;span style="position:relative;left:-999px;"&gt;图标&lt;/span&gt;&lt;/i&gt; 答案是：忽略，不会读取！ 12、 还没完，我还有最后一口气，终极绝招，如果文字是透明的，那会不会读取呢？ 1&lt;i class="icon" style="color:transparent;"&gt;图标&lt;/i&gt; 恭喜你，会读取！ ③ 文字基于内联盒子片段读取 如下一段简单常见的HTML代码： 1&lt;p&gt;总共消费&lt;output&gt;500&lt;/output&gt;元&lt;/p&gt; 请问，touchstart 或 touchmove 该元素的时候读取的信息是？ 结果：要么「总共消费」，要么「五百」，要么「元」。是不会连续读取「总共消费500元」的。完全是基于内联盒子来读取的，例如这里「总共消费」和「元」是两个「匿名内联盒子」，外面有 output 标签的「500」是内联盒子。 但是，如果是 &lt;h1&gt;~&lt;h6&gt; 标题元素，则例外，例如： 1&lt;h6&gt;总共消费&lt;output&gt;500&lt;/output&gt;元&lt;/h6&gt; 读「总共消费500元-标题级别6」。 二. 对于替换元素① 替换元素永远不会穿透 比方说一开始的这个图： 要避免穿透，我们使用 role 属性将标签角色变成替换元素，例如设置 role=”button” ，如下截图： ② 替换元素title属性读取 还是上面那个免费图形： 1、 如果HTML是下面这样： 1&lt;i class="icon" role="img" title="图标"&gt;&lt;/i&gt; 则 title 属性值是会读取的，这里会读「图标 图像」。 2、 如果角色是替换元素，则 aria-label 描述信息也会读取： 1&lt;i class="icon" role="img" aria-label="图标"&gt;&lt;/i&gt; 3、 role=”img” 元素里面文本不读取，这个很好理解，原生的图片标签里面是不能哟文字内容的。 1&lt;i class="icon" role="img"&gt;图标&lt;/i&gt; 此时只会读“图像”，里面的文字“图标”被忽略了。 4、 role=”button” 非 display 隐藏文本均读取，也就是 color 透明隐藏，font-size: 0 隐藏，visibility: hidden 隐藏，text-indent 缩进隐藏，absolute 屏幕外隐藏。都是读取的。 但是，如果是 display: none，则忽略： 1234&lt;i class="icon" role="button"&gt; &lt;span hidden&gt;图标&lt;/span&gt; &lt;!-- “图标”不读取 --&gt;&lt;/i&gt; 5、 设置 aria-hidden=”true” 元素不可读不可点。 123&lt;i class="icon" role="button"&gt; &lt;span aria-hidden="true"&gt;图标&lt;/span&gt; &lt;!-- “图标”不读取 --&gt;&lt;/i&gt; aria-hidden=”true” 是 ARIA 无障碍处理售后非常常用的一个属性，所有的装饰性元素或者点击区域太小的元素都应该设置 aria-hidden=”true”，避免无谓信息对用户的干扰。 6、 当内容，标题等信息同时存在时候的读取顺序是：优先内容，然后类型，然后标题，例如： 1&lt;i class="icon" role="button" title="示意"&gt;图标&lt;/i&gt; 读：「图标，按钮」，明显停顿后，「示意」。注意，读 title 属性之前有个非常非常明显的停顿，停顿时间之长，感觉就像朗读人断片了一样。 7、 aria-label 作用和文字内容类似，但是优先级更高。也就是同时存在的时候，文字内容读取会被忽略，例如： 1&lt;i role="button" aria-label="图标1" title="示意"&gt;图标2&lt;/i&gt; 读：「图标1，按钮」，明显停顿后，「示意」。「图标2」不会读取，被忽略！ 如果希望读内部信息，同时又自定义一些信息，可以使用 aria-describedby，aria-describedby 的行为表现和语义有些类似于 title 属性，aria-describedby 的属性值只能是元素 id，这非常适合保证原始标签语义同时告知辅助信息的场景，例如： 12&lt;h3 aria-describedby="ariaDesc1"&gt;热门小说&lt;/h3&gt;&lt;span id="ariaDesc1" aria-hidden="true"&gt;编辑推荐&lt;/span&gt; 8、 大段描述可以使用 aria-labelledby 或 aria-describedby，例如 12&lt;i role="button" aria-labelledby="id"&gt;图标2&lt;/i&gt;&lt;p hidden id="id"&gt;这是一个...图标&lt;/p&gt; 读：「这是一个…图标，按钮」。 可以看到，目前描述元素即使 display: none 也是可以读取的。aria-labelledby 或 aria-describedby 的属性值对应描述信息元素的 id 属性值，可以是多个，使用空格分隔，例如： 1&lt;i role="button" aria-labelledby="id1 id2 id3"&gt;图标2&lt;/i&gt; 9、 &lt;nav&gt; 会读「导航，标志性内容」，&lt;header&gt; 读「横幅，标志性内容」，&lt;footer&gt; 读「页脚，标志性内容」。 然后，若触发的是子元素，仅第一次触发读取上面的信息。例如，导航中有两个链接，则轻触第一个的时候，读「xx, 链接，导航，标志性内容」，紧接着轻触第二个链接的时候，仅仅会读「xx, 链接」。 出乎意料的是，&lt;ul&gt;, &lt;ol&gt; 不会读列表，需要增加 role=&quot;listbox&quot;，这样，触发 &lt;li;&gt; 元素的时候会读“列表，第一个”。 所有 form 原生控件都能准确读取，包括状态。因此，一定要养成基于元素表单控件实现交互效果的习惯，控件丑没关系，透明度 opacity:0 覆盖处理之，例如，单选项，复选框效果等。 10、 后面这些角色设置可让断片文本连读：role=&quot;button&quot;, role=&quot;tab&quot;, role=&quot;heading&quot;, role=&quot;combobox&quot; 等。 1&lt;p role="button"&gt;总共消费&lt;output&gt;500&lt;/output&gt;元&lt;/p&gt; 读：「共消费500元，按钮」。 虽然很好地解决了多个内联元素读取「断片」的问题，但是，不合语义，明明不是按钮，你说是按钮，问题很大。 后来，经过我的各种尝试，发现了一个无语义文本连读技巧，就是使用： role=&quot;option&quot;。 option 值源自 HTML 下拉列表的 &lt;option&gt; 标签。option 可以让里面文字连读的原理是，原生的 &lt;option&gt; 标签中只能是纯文本，会忽略一切的 HTML 标签，于是，设置了 role=&quot;option&quot;，就会当 &lt;output&gt; 标签不存在，从而连读，并且选中的高亮框范围也更加合理。 11、 使用 role=&quot;option&quot; 连读的时候会可能会存在内容断句不清的情况。例如： 12345678&lt;li class="fans-li" role="option"&gt; &lt;div class="rel"&gt; &lt;aria&gt;粉丝第1名：我是大帅哥&lt;/aria&gt; &lt;/div&gt; &lt;div class="rel"&gt; &lt;aria&gt;粉丝等级：&lt;/aria&gt;LV4 &lt;/div&gt;&lt;/li&gt; 此时朗读效果为「粉丝第1名 我是大帅哥粉丝等级 LV4」（空格表示停顿）。实际上，「我是大帅哥粉丝等级」中间应该有明显的断句。怎么办呢？可以使用英文句号，也就是点结束符，可以产生明显断句，比全角的冒号「：」似乎还要断句明显。修改如下（「我是大帅哥后面加了个点，隐藏」）： 123456789&lt;li class="fans-li" role="option"&gt; &lt;div class="rel"&gt; &lt;aria&gt;粉丝第1名：我是大帅哥.&lt;/aria&gt; &lt;/div&gt; &lt;div class="rel"&gt; &lt;aria&gt;粉丝等级：&lt;/aria&gt; LV4 &lt;/div&gt;&lt;/li&gt; role 属性值设置会覆盖原始的语义，例如： 1&lt;a href role="option"&gt; 总共消费&lt;output&gt;500&lt;/output&gt;元&lt;/a&gt; 读：「共消费500元」，不会提示「链接」。 由于 &lt;option&gt; 标签里面只能是纯文本，因此，role=&quot;option&quot; 连里面的一切语义也会忽略，于是： 123&lt;li role="option"&gt; &lt;a href&gt;总共消费&lt;output&gt;500&lt;/output&gt;元&lt;/a&gt;&lt;/li&gt; 读：「共消费500元」，不会提示「链接」。 如果遇到这种尴尬，可以这么处理： 123&lt;li role="link"&gt; &lt;a href role="option"&gt;总共消费&lt;output&gt;500&lt;/output&gt;元&lt;/a&gt;&lt;/li&gt; 也就是原语义外置。此时读：「共消费500元，链接」，这下没毛病了。 三. 交互与 aria1、 VoiceOver 开启时，原来的 touchmove 是高成本操作，因此，需要增加详细的描述信息，否则用户根本不知道是个什么鬼？例如下面一段截图示意： 复杂交互场景，或者和原生控件交互不一致的交互场景，需要添加交互场景描述，例如下面示意： 需要同步改变描述和状态，例如面板展开和收起的时候，例如： 此时，先要使用 role=”menuitem” 定义是菜单项，然后使用 aria-expanded 标记是展开还是收起，VoiceOver 会自动根据此状态值读出对应的中文状态描述的。 1&lt;a href class="icon-more" title="更多" role="menuitem" aria-expanded="false"&gt;&lt;/a&gt; 展开时候 aria-expanded 设为 true： 1&lt;a href class="icon-more" title="收起更多" role="menuitem" aria-expanded="true"&gt;&lt;/a&gt; 上面例子中的 aria-expanded 就是 ARIA 中的状态属性，常用的其他属性还包括（需要配合特定的 role 属性值才有效）： aria-expanded 展开还是收起，菜单，自定义下拉等用的比较多。 aria-checked 选中还是未选。 aria-selected 选中还是未选。 aria-disabled 禁用还是可用。 aria-hidden 隐藏还是显示。 aria-invalid 验证正确还是错误。 其中 aria-checked 和 aria-selected 含义类似，那什么时候该用什么呢？ aria-checked 多用在单选复选上，aria-selected 多用在下拉列表上，或者选项卡role=”tab”上。 说到 role=”tab” 选项卡，有一个注意点需要提一下，role=”tab” 一定要加在平级的兄弟元素上，例如： 12345&lt;nav&gt; &lt;h3 role="tab"&gt;&lt;a href&gt;选项卡1&lt;/a&gt;&lt;/h3&gt; &lt;h3 role="tab"&gt;&lt;a href&gt;选项卡2&lt;/a&gt;&lt;/h3&gt; &lt;h3 role="tab"&gt;&lt;a href&gt;选项卡3&lt;/a&gt;&lt;/h3&gt;&lt;/nav&gt; 千万不要这样： 12345&lt;nav&gt; &lt;h3&gt;&lt;a href role="tab"&gt;选项卡1&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href role="tab"&gt;选项卡2&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href role="tab"&gt;选项卡3&lt;/a&gt;&lt;/h3&gt;&lt;/nav&gt; 因为后面每个选项卡会认为就一个单独的选项卡，读「共1个」，前者可以正确读「共3个」。另外，VoiceOver 读取的时候不是读「选项卡」，听上去是「标间」，开房吗？ Aria 交互启示 浮层半透明遮罩如果有交互，需分层，并设置 role，如果点击整片区域都有行为，不要取巧使用冒泡，因为在无障碍处理的时候会很啰嗦，直接使用一个透明图层覆盖，设置合适的 role 以及描述； 浮层右上角要有关闭按钮，哪怕是透明的，千万不要信了设计师的邪，认为例如，弹框上有取消按钮，还搞个关闭干什么，不好看啰嗦。其实对于视力不好的用户，最习惯的是去屏幕右上区域找到关闭按钮。又或者浮层可以直接手指一划移出，不需要关闭按钮，那都是很自以为是的想法。如果设计师坚持，我们做开发的也需要在右上角加一个正常用户看不见的透明的关闭按钮，读屏设备是可以获取的。浮层关不掉是非常非常体验差的一件事情。 自定义控件最好使用原生控件覆盖 opacity:0，因为你这样处理后，根本不要再有任何额外的 HTML 或者 JS 支持就能有完美的无障碍访问了。 交互样式改变可以尝试直接使用 aria 属性控制，一举两得，例如，使用 aria-checked 属性而不是 .checked 类名，可以有效降低后期无障碍支持成本。 避免自定义的 touchmove 交互，因为开启读屏模式后，touchmove 交互成本很高。 四. 其他ARIA无障碍支持经验补充① 将视觉信息转换成文字信息 例如下图： 这是个搜索列表，其中，有两个小色块，我们一看就能看明白是「标签」，而后面2个列表右侧是灰色文字，我们可以看出来是作者名。但是，对于靠触摸的盲人用户，颜色，大小包括位置都是看不到的，因此，他就很难区分这些信息是什么意思，VoiceOver 会这么读： 巫妖王作者 武侠分类 武说谭家三十 武侠世界独孤起步 估计用户心中是这幅表情： 因此，我们需要将视觉信息转换成文字，我的做法将必要的文字内容使用 clip 隐藏放在标签中： 1234aria &#123; position: absolute; clip: rect(0,0,0,0);&#125; 此时，设备读取就是： 巫妖王 标签：作者 武侠 标签：分类 武说 作者：谭家三十 武侠世界 作者：独孤起步 ② 小区域重要标志信息合并 有些信息很重要，但是占据空间很小，或者隐蔽，此时，最好信息合并，例如，图书上的限免标志： 我们可以给「限免」标志设置 aria-hidden=”true”，然后把该信息和图片信息合并，如下代码截图示意： ③ 关于SVG的无障碍访问 请问，有个 SVG 图标代码如下，清除轻触是否会有信息读取？ 1234&lt;svg class="icon icon-arrow-l”&gt; &lt;title&gt;返回&lt;/title&gt; &lt;use xlink:href="#icon-arrow-l"&gt;&lt;/use&gt;&lt;/svg&gt; 结果，只会读「图像」，然后就没有然后了。这其实跟上面 role=”img” 的标签里面文字不读原理是一样的，就是原生图像里面是不会有文字信息的，因此，这里 123456&lt;a href&gt; &lt;svg class="icon icon-arrow-l”&gt; &lt;title&gt;返回&lt;/title&gt; &lt;use xlink:href="#icon-arrow-l"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/a&gt; 请问，会有信息读取吗？ 答案是：会读「返回，链接」。因为此时 SVG 从图像性质变成了链接内容。有人会问了，如果我想单纯 SVG 标签读取信息怎么办？可以如下处理： 1234&lt;svg role="img" aria-label="返回"&gt; &lt;title&gt;返回&lt;/title&gt; &lt;use xlink:href="#icon-arrow-l"&gt;&lt;/use&gt;&lt;/svg&gt; 此时，会读「图像，返回」。 「以上就是此物的使用方法，好了，你们现在可以走了！」说完，大手一挥，中年人自己信步离开了。 「前辈？」『起床气』正有疑惑想继续追问，结果一眨眼，就没了人影。大家互相看了看，只能悻悻离开。虽然此番体验不佳，但好在大家都安全回到学院，东西也亲手交给院长『软大』，也算完成了任务。倒是接下来的一些信息让大家意外了。 「柯学长没有为难你们吧？」『软大』问道。 「柯学长？学长？」众人疑惑不已，「院长，你是说的那个瞎子，哦不，『飞天前辈』是我们的学长？」「对呀，他可是学院第一届学生中感知力最强的人，因为小时候吃苹果中毒失去了视力，因此，感应反而比一般人要强好多倍，就和五感尽失的陈长生神识变得更强一样，就算是密封器物中的泉之力也能感应。尤其黑夜中更是如鱼得水，因为被人称为『飞天蝙蝠』。后来因为某些事情提前退休，不然说不定现在是你们的老师……」 「诶…」众人心中嘀咕，「还好不是我们的老师~~」 PS: 本故事世界观和背景可参见 GitHub]]></content>
      <categories>
        <category>无障碍访问</category>
      </categories>
      <tags>
        <tag>无障碍访问</tag>
        <tag>Mobile</tag>
        <tag>VoiceOver</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哇牛叉学院之超简缓动动画小算法]]></title>
    <url>%2F2018%2F06%2F01%2F20180601%2F</url>
    <content type="text"><![CDATA[本集出场人物：张小师、波波、神官、阿坤、萤火友情客串：张小凡特别感谢：康康兔 夜渐渐暗了下来，在例行任务结束后，『张小师』和队友们并没有像以往一样，积极忙忙赶回「哇牛叉学院」，因为，这是过年前的最后一次任务，等回到学院，大家可能就要暂时分别一段时间。这一年的奋战已经够辛苦了，所以大家觉得可以一起找个地方放松下。“要不我们去「青云餐馆」吃烤兔子？”『波波』提议，“好啊！”众人一拍即合！ 「青云餐馆」坐落于青云山脚下，互联 14 年由萧鼎所建，主厨名叫张小凡，一手烤兔子的绝活远近闻名，现烤现吃，不过张小凡本人是不出面的，都是学徒们出来现烤，除非是「阅之国」皇亲国戚这样的重要人物或者出重金的商人才有此待遇。 当然，『张小师』一行人前去吃烤兔子就是单纯吃烤兔子，并未想过与见到传说中的主厨张小凡，更没有奢想张小凡会亲自为这么几个普通的客人烤兔子。但是，这一天发生的事情完全超出了大家的预料。 『波波』的技能是［人品加护］，也就是任务攻略完毕 100% 捡到宝贝。但很多时候，捡到的这些宝贝似乎是假宝贝，比方说，“服用后 100% 腹泻的精灵石”，“遇水即化的泳衣”以及“先脱发再生发秘制生发灵”等等，并不实用，于是都给卖了。 但是，这一次，［人品加护］似乎迎来了大爆发…… 众人包间就坐，点好了大号烤兔子，边闲聊边等待厨师出现。很快，包间的门推开了，一个略显帅气的身影出现了，戴着高高的厨师帽，推着串着整只兔子烤架进来了，一切都很自然一切都很平常。但是，当厨师抬起头的时候，不知谁突然尖角了一声，众人面面相觑，此不知哪里窜出一个声音，“你……是不是就是那个传说中比宋仲基还帅比李易峰还酷厨艺出神入化「青云餐馆」大当家，张小凡？” 厨师微微一笑，默不作声。“没错，一定是你！我『阿坤』的［记忆宫殿］技能之一就是过目不忘。2 年前我们「阅之国」成立时候照片中就有你。” “喔噢，不会吧……”大家都惊讶地看着彼此。因为现在这种状况就等同于在薛之谦开的火锅店吃火锅但是薛之谦亲自为你服务，大家都不敢相信，纷纷开始索要签名。 “诸位稍安，再耽搁就错过兔肉最佳烧烤时间了，我们不妨先饱食欲，签名之事可以等兔肉烤完再说也不迟，不知可否？” “恩，可以的”，『神官』摆了摆手，让大家安静。 然后，厨师开始了娴熟的烤兔子制作…… 此时，『波波』没忍住，问道：“请问，你现在是在拍真人秀节目吗？否则您这样的大人物怎么会亲自给我们烤兔子呢？” “这个嘛，说来也惭愧”，厨师边给兔子划口子边说道，“本来我有 6 名弟子，现在要过年了，客人也少，就有 2 人我让他先回老家了，剩下的 3 名弟子，一个便秘很多天于是吃腹泻精灵石，结果没控制住量，拉到腰都直不起来；还有名弟子更惨，女朋友穿着的他送的泳衣去泡混合温泉，结果泳衣化掉了，结果跪了一晚上的烧烤架，腿算是废了；还有个弟子不知服了什么药，掉发太厉害，帽子都兜不住，我们做餐饮的最怕食物有头发，所以我只能让他休息几天；最后 1 个弟子倒是没什么事，但是，今天白天基本上客人都是他一个人应付的，已经累得看不清兔子有几条腿了。所以，现在只能我自己上了，放心，价格还是普通的价格。”说完又是蜜汁微笑。 “哦~~”『波波』若有所思地应道，好像突然想到了什么。 划好口子，只见厨师拇指和食指相交成爱心，形成一个比心手势，然后轻轻一撮，一股森白火焰从指头冒出。 此技一出，众人哗然，要知道，要想将「泉之力」直接转成火焰可是非常罕见非常高阶的技能，这厨师点火如此轻松娴熟，这背后的实力怕是深不可测。更加确信，此人就是张小凡。 然后，只见手指轻轻一弹，原本指尖的火焰瞬间消失，转而烤架下方出现了薄薄的一层火焰，众人正奇怪这么小的火，看上去温度也不高，怎么烤兔子的时候，厨师突然解印，速度之快，普通人看上去就是手掌一翻，能力者可以看出有解印，但不知细节，只有『阿坤』凭借［记忆宫殿］技能看清了巳-未-申-亥-午-寅的解印顺序。然后，一股悠长绵延的「泉之力」向烤架下方的火焰奔去，只见火焰立马有了灵性，将兔子缓缓围住，黄白火焰有规律地在兔身周围顺时针缓慢旋转。 “好厉害！”感知敏锐的『起床气』不由得发出感叹，“「泉之力」外放已经很难，平常所见外放都是直接刚烈，没想到居然可以这般由快变慢，同时聚而不散，这要比『萤火』的［激光外放］要难啊！” “过奖了！”厨师显得很轻松，接着说道，“其实这「泉之力」外放缓动技能看上去很玄奥，实际上并不难学，而且好处不仅仅是可以很好地控制火候，我知道你们经常要抓小精灵，如果「泉之力」发出过于生硬，过于蛮力，除了浪费自己力气外，还会惊扰到其他精灵而逃逸消失，所以，对于你们日常工作也是很有帮助的。不知道你们有没有兴趣学习，我可以现场教给你们，报酬嘛…… 恩，就在「哇牛叉学院」的故事坊中好好宣传下我的「青云餐馆」，不知成交否？” “好！”大家异口同声答到。 “好，正好兔子烤好还需要点时间，我们可以边聊变等”，厨师边悠然说道边悠哉地释放绵延但厚重的「泉之力」。 “此技能是我年轻获得的……” 让交互蓬荜生辉的超简缓动小算法 原理如下： 假设要从位置 A 变化到位置 B，如果是生硬线性运动，则每次移动距离是一样；如果是缓动，每次移动距离不一样。那如何才能不一样呢？很简单，按比例移动就可以。 例如：每次移动剩余距离的一半。 对吧，超容易理解的。 比方说：你和烧烤架之间距离是 64，每秒移动一半，则，你们之间的距离下一秒就是 32,再下一秒就是 16，然后 8，然后 4，然后 2，然后 1，然后……你们就在一起了。你们在一起的这个过程就是一个典型的先快后慢的缓动运动过程，示意如图1： 用一个简单的公式表示就是： 1A = A + ( B - A ) / 2 翻译一下就是： 1我下一秒的位置 = 现在位置 \+ 现在和烧烤架之间距离的一半 是不是很好理解。 而上面的 A=A+(B-A)/2 就是我要分享给大家的即插即用的缓动小算法。 当然要实际使用还是需要做一点点的处理的，首先，要让运动连绵不绝，那就离不开定时器，我们可以使用 requestAnimationFrame，对于不支持的浏览器，可以使用下面的兼容代码： 123456//requestAnimationFrame的兼容处理if(window.requestAnimationFrame)&#123; requestAnimationFrame = function(fn)&#123; setTimeout(fn,17); &#125;; &#125; 然后，实际缓动的比例不会是 2，有可能是 3 或者 4 之类，也是个变量，因此，完整的核心算法公式是： 1A = A + ( B - A ) / rate 于是，我们火烤兔子的缓动释放效果就可以使用下面的代码表示： 123456789101112131415161718//泉之力的位置var fireToRabbit = function() &#123; var A = 64, B = 0, rate = 2; var top = function() &#123; A = A + ( B - A ) / rate; //临界判断，终止运动 if( A &lt; 1 ) &#123; distance = B; return; &#125; distance = A; //运动gogogo! requestAnimationFrame(top); &#125;; top();&#125;; 等比例靠近理论上最终只会无穷靠近，并不会真正的相等，也就是运动永远没有结束的时候，所以说需要做一个临界判断，也就是距离小到一定数目的时候，直接等于目标值，并终止动画。例如，上面就是当距离烧烤架的距离小于 1 的时候，直接终止运动，释放「泉之力」，生成火焰。 1234if( A &lt; 1 ) &#123; distance = B; return;&#125; 我们最近刚上线不久的新版的起点移动站的返回顶部效果（见图2）就是使用的这个缓动小算法。 当然，M 站使用这个动画小算法的地方不止这一个，比方说首页最近阅读的小球是可以移动的，惯性运动动画效果就是用的该算法，还是书籍阅读页面水平看书模式时候移来移去的翻页效果（见图3），也是此算法；垂直模式时候点击翻屏也是该算法等等，用得非常多。 这种算法非常简单实用，项目中经常会不止一个地方使用，于是就出现这样的问题，如果每次缓动都写一遍 requestAnimationFrame 和边界判断就会很啰嗦的，于是，我们可以把算法变个身，例如下面这样： 1234567891011121314151617Math.easeout=function(A,B,rate,callback)&#123; if( A == B || typeof A != 'number') &#123; return; &#125; B = B || 0; rate = rate || 2; var step = function() &#123; A=A+(B-A)/rate; if( A &lt; 1 ) &#123; callback(B,true); return; &#125; callback(A,false); requestAnimationFrame(step); &#125;; step();&#125;; 其中： A 是起始位置； B 是目标位置； rate 是缓动速率； callback 是变化的位置回调，支持两个参数，value 和 isEnding，表示当前的位置值（数值）以及是否动画结束了（布尔值）； 于是，我们的返回顶部效果可以这么使用： 1234var doc = document.body.scrollTop ? document.body : document.documentElement;Math.easeout(doc.scrollTop,0,4,function(value)&#123; doc.scrollTop = value;&#125;); 可以看到效果是一样的棒棒哒。更关键点是我们的算法可以更简单地重复利用了，也就是无论是抓小精灵还是烧烤，只能掌握此技能，都能非常方便使用，即插即用。 实际上，业界还有更全面的 Tween.js 标准的缓动算法，但是，这个算法是是基于时间来做算法的，而我刚刚展示的 Math.easeout 算法是基于缓动速率的，最终的时间是不固定的，受起始和终止位置的距离的影响，也正是这个原因，本文的缓动动画算法更好理解更容易记忆，因为现实世界距离是真实的容易感知的，时间是虚幻的无法捕捉的，正好和本文的算法距离驱动而非时间驱动相映射，容易形成共识。 “恩，就这些，不知大家听完之后有什么感想？” “太厉害了！”『张小师』听完不禁竖起了大拇指，“真可谓，听君一席话胜读十年书！没想到阁下不仅厨艺了得，这「泉之力」掌控之技也如此出神入化，再下佩服地五体投地，自愧不如！” “哈哈，那就好，答应我的事情可别忘记哦”，说完，厨师右手手腕一翻，一个罐状物出现在手中，左手一收，顿时兔身周围如星云绕日般的火焰顿时犹如失去了呼吸，瞬间只剩下底部的一层薄薄略带袅袅的森白之火，然后，右手猛地一震，罐中粉末状物体悉数迸出，手掌朝下，再迅速翻过来，手上已经空空如也，只有刚刚迸出的调味料犹如时间停止般禁锢悬空在手掌上方，实际上，调味料是被手中散发的「泉之力」包裹起来了，这感知力和操控技术，可以和学院顶级的「品器测量师」相媲美了。然后，只见五指如划水般轻轻拨弄，调味粉末慢慢散开，隐隐中似乎被五道线路引导，均匀地环绕并依次吸附在兔身周围，并发出轻轻的滋滋声，很快调味粉末一点不差全部均匀撒完了。 大家正以为已经结束可以开吃的时候，突然，厨师左手用力一捏，再猛然张开，往前一推，底下原本那一层薄薄的懒散的火焰，突然如火龙一样，随着“轰”地一声，迅速爆燃开来，准确讲应该是火蛇，周身全部都是熊熊的红色火焰的火蛇，将兔子紧紧缠绕起来。 这来势之突然，景色之壮观，在座不少人都惊呼出声，正当准备回味的时候，突然厨师左手一收，火蛇顿时散去的无影无踪，同时，兔身周围的那些佐料粉末也消失得无影无踪，整个房间只剩下油火冷却的滋滋声以及按耐不住四处散逸的兔肉的香味。 “好了，可以吃了！” 大家这才晃过神来，开始立马纷纷拿起手机拍照留恋，然后瞬间变成饿狼，顾不得嘴角早已垂涎三尺的口水，扑向无辜的小兔子…… 那一晚，大家都流泪了，不是因为要分别，也不是因为学到了新的缓动技能，而是那外焦里嫩的口感，弥而不散的香味实在让人欲罢不能。每吃一口，味蕾都要接受一浪又一浪不能自已的挑拨，感觉就像自己在云雾中漫游，天地间徜徉，实在好吃到哭，感动到泪。 PS: 本故事世界观和背景可参见 GitHub]]></content>
      <categories>
        <category>animation</category>
      </categories>
      <tags>
        <tag>animation</tag>
        <tag>requestAnimationFrame</tag>
        <tag>Mobile</tag>
      </tags>
  </entry>
</search>
